
\chapter{Experimental Results}

The data sets following are complete git repositories which have been examined to discover the proportion of changes to behavior compared to ascetic changes that do not affect the behaviour of the program. 

% in table ~\ref{tab:DataSets}
% 
% \begin{table}
%   \caption{Complete git repositories that are tested}
%   \label{tab:DataSets}
%   \begin{center}
%     \begin{tabular}{|c|c|c|}
%        Jasm & this a a Java bytecode assembler
%        written for use with the Whiley programming language. & 
% https://github.com/Whiley/Jasm\\
%       foo & bar \\
%     \end{tabular}
%   \end{center}
% \end{table}
% 

\begin{itemize}
  \item Jasm - this a a Java bytecode assembler written for use with the Whiley programming language. https://github.com/Whiley/Jasm
  \item Jpp - this is a preproccessor for Java based on Bash shell script. https://github.com/maandree/jpp
  \item AST Java - a small parser wriiten to transform Java into an AST. https://github.com/klangner/ast-java
  \item Java Object Diff - allows two Java objects to be compared https://github.com/SQiShER/java-object-diff
  \item DiffJ - a diff tool which in addition to ignoring white space ignores changes of ordering in package names for a Java file https://github.com/jpace/diffj
\end{itemize}


There are a number of Java categories that the Refactor Categories Tool will recognise.  Apart from the traditional insert, delete and modify it will aslo recogise if an Ast Node has been renamed but the content and type of the node remains the same.  It will recognise valid moves within a scope. It will also recognise when the text based merge got it wrong by claiming that the code was not fuctionally equivalent when in fact it was.

Apart from this it will also diferentiate between Java code and comments.  It can tell if comments have been inserted, modified, moved or deleted.  It will also pick up any changes to that whitespace that have not already been figured out by the text based comparison.  

 
% Comments
%     Insert
%     Delete
%     Modify
%     Move
% White space
%    Modify
% 
% Java
%  Insert
%  Delete
%  Modify
%  Move
%  Rename


REFACTOR CATEGORIES:COMMENT:DELETE
-----Added another t:/Main.java:(438273, 438276)-----
				
>>>>>More little twe:/Main.java:(438273, 442372)>>>>>
				// FIXME: get this working!!
				
------------------------------------
-----More little twe:/ClassFileReader.java:(5562434, 5578755)-----
 
			// FIXME: I believe it's possible that have an array type here. This
			// is necessary to support cloning of arrays, which is implemented
			// by an invokevirtual bytecode.
			
>>>>>Minor bug fix f:/ClassFileReader.java:(5566520, 5570561)>>>>>

	
------------------------------------
-----Minor bug fixes:/JKitValidTests.java:(368641, 368644)-----
				
>>>>>Added classfile:/JKitValidTests.java:(364545, 372737)>>>>>
				// FIXME: get this working!!
				// new TypeAnalysis().apply(cf);
	
------------------------------------
Git diff =0  Refactor Categories =7

REFACTOR CATEGORIES:COMMENT:INSERT
-----Added another t:/TypeAnalysis.java:(995329, 1003523)-----
			// This is a fall back, since it is permitted to perform an array
			// load / store on the null type.
			
>>>>>More little twe:/TypeAnalysis.java:(991233, 991235)>>>>>
			
------------------------------------
-----More little twe:/ClassFileReader.java:(5562434, 5578755)-----
 
			// FIXME: I believe it's possible that have an array type here. This
			// is necessary to support cloning of arrays, which is implemented
			// by an invokevirtual bytecode.
			
>>>>>Minor bug fix f:/ClassFileReader.java:(5566520, 5570561)>>>>>

	
------------------------------------
-----Minor bug fix f:/TypeAnalysis.java:(1880065, 1884162)-----
		// TODO: I'm slightly unsure whether or not this is a good idea!
		
>>>>>Bug fix for non:/TypeAnalysis.java:(1880065, 1880066)>>>>>
		
------------------------------------
Git diff =0  Refactor Categories =6

REFACTOR CATEGORIES:COMMENT:MODIFY
-----Minor bug fix f:/TypeAnalysis.java:(970755, 970758)-----
if (
>>>>>Bug fix for non:/TypeAnalysis.java:(970755, 970757)>>>>>
if(
------------------------------------
-----Minor bug fix f:/TypeAnalysis.java:(970820, 970821)-----
) 
>>>>>Bug fix for non:/TypeAnalysis.java:(970787, 970788)>>>>>
) 
------------------------------------
-----Minor bug fixes:/Code.java:(155649, 159745)-----
 * This represents the Code attribute from the JVM Specification.
 
>>>>>Added classfile:/Code.java:(163841, 167937)>>>>>
 * This represents the Code attribute from the JVM Spec.
 
------------------------------------
Git diff =0  Refactor Categories =80

REFACTOR CATEGORIES:WHITESPACE:MODIFY
-----More little twe:/TypeAnalysis.java:(1069057, 1069058)-----
		
>>>>>Minor bug fix f:/TypeAnalysis.java:(1069057, 1069058)>>>>>
		
------------------------------------
-----More little twe:/TypeAnalysis.java:(1069101, 1073153)-----
		
	
>>>>>Minor bug fix f:/TypeAnalysis.java:(1093636, 1097729)>>>>>

	
------------------------------------
-----Minor bug fix f:/TypeAnalysis.java:(1884205, 1888257)-----

	
>>>>>Bug fix for non:/TypeAnalysis.java:(1880109, 1884161)>>>>>

	
------------------------------------
Git diff =0  Refactor Categories =21

REFACTOR CATEGORIES:JAVA:DELETE
-----More little twe:/ClassFileReader.java:(5562372, 5562433)-----
String ownerString = getString(read_u2(read_u2(index, 0), 0));
>>>>>Minor bug fix f:/ClassFileReader.java:(5562372, 5566519)>>>>>
owner = parseClassDescriptor("L"
					+ getString(read_u2(read_u2(index, 0), 0)) + ";");
------------------------------------
-----More little twe:/ClassFileReader.java:(5578756, 5578809)-----
owner = parseClassDescriptor("L" + ownerString + ";");
>>>>>Minor bug fix f:/ClassFileReader.java:(5562372, 5566519)>>>>>
owner = parseClassDescriptor("L"
					+ getString(read_u2(read_u2(index, 0), 0)) + ";");
------------------------------------
-----Minor bug fix f:/TypeAnalysis.java:(1884183, 1884191)-----
code.type
>>>>>Bug fix for non:/TypeAnalysis.java:(1880082, 1880090)>>>>>
code.type
------------------------------------
Git diff =0  Refactor Categories =119

REFACTOR CATEGORIES:JAVA:INSERT
-----Minor bug fix f:/TypeAnalysis.java:(1884199, 1884202)-----
orig
>>>>>Bug fix for non:/TypeAnalysis.java:(1880097, 1880101)>>>>>
index
------------------------------------
-----Minor bug fixes:/TypeAnalysis.java:(2768902, 2768940)-----
"expected type " + t1 + ", found type "
>>>>>Added classfile:/TypeAnalysis.java:(2756666, 2756681)>>>>>
"expected type "
------------------------------------
-----Minor bug fixes:/TypeAnalysis.java:(2768944, 2768945)-----
t2
>>>>>Added classfile:/TypeAnalysis.java:(2760712, 2760713)>>>>>
t1
------------------------------------
Git diff =0  Refactor Categories =11

GIT DIFF:JAVA:MODIFY
====================================
-----Added another t:/Main.java:(438273, 442369)-----
				new ClassFileVerifier().apply(cf);				
	
>>>>>More little twe:/Main.java:(438273, 446465)>>>>>
				// FIXME: get this working!!
				new TypeAnalysis().apply(cf);				
	
------------------------------------
-----Added another t:/TypeAnalysis.java:(995329, 1007617)-----
			// This is a fall back, since it is permitted to perform an array
			// load / store on the null type.
			store.push(JvmTypes.T_VOID);
	
>>>>>More little twe:/TypeAnalysis.java:(991233, 999425)>>>>>
			throw new VerificationException(method, index, store,
					"arrayload expected array type");
	
------------------------------------
-----More little twe:/ClassFileReader.java:(5513217, 5517313)-----
		JvmType owner = null;
	
>>>>>Minor bug fix f:/ClassFileReader.java:(5513217, 5517313)>>>>>
		JvmType.Clazz owner = null;
	
------------------------------------

REFACTOR CATEGORIES:JAVA:MODIFY
-----Added another t:/Main.java:(438277, 438299)-----
new ClassFileVerifier()
>>>>>More little twe:/Main.java:(442373, 442390)>>>>>
new TypeAnalysis()
------------------------------------
-----Added another t:/Main.java:(438307, 438308)-----
cf
>>>>>More little twe:/Main.java:(442398, 442399)>>>>>
cf
------------------------------------
-----Added another t:/TypeAnalysis.java:(1003524, 1003551)-----
store.push(JvmTypes.T_VOID);
>>>>>More little twe:/TypeAnalysis.java:(991236, 995366)>>>>>
throw new VerificationException(method, index, store,
					"arrayload expected array type");
------------------------------------
Git diff =335  Refactor Categories =243

REFACTOR CATEGORIES:JAVA:MOVE
-----Minor bug fix f:/TypeAnalysis.java:(1884178, 1884181)-----
type
>>>>>Bug fix for non:/TypeAnalysis.java:(1880092, 1880095)>>>>>
type
------------------------------------
Git diff =0  Refactor Categories =1

REFACTOR CATEGORIES:JAVA:RENAMED
-----More little twe:/TypeAnalysis.java:(970790, 974849)-----
{
	
>>>>>Minor bug fix f:/TypeAnalysis.java:(970822, 974849)>>>>>
{
	
------------------------------------
-----Minor bug fix f:/TypeAnalysis.java:(970822, 974849)-----
{
	
>>>>>Bug fix for non:/TypeAnalysis.java:(970789, 974849)>>>>>
{
	
------------------------------------
-----Minor bug fix f:/TypeAnalysis.java:(1069125, 1073153)-----
{
	
>>>>>Bug fix for non:/TypeAnalysis.java:(1069093, 1073153)>>>>>
{
	
------------------------------------
Git diff =0  Refactor Categories =28

REFACTOR CATEGORIES:JAVA:EQUIVALENT
-----Minor bug fix f:/TypeAnalysis.java:(1708033, 1712129)-----
		if (!(type instanceof JvmType.Array || type instanceof JvmType.Null)) {
	
>>>>>Bug fix for non:/TypeAnalysis.java:(1708033, 1712129)>>>>>
		if (!(type instanceof JvmType.Array)) {
	
------------------------------------
-----Bug fix for put:/ClassFileReader.java:(3985409, 3989505)-----
			if(opcode == Bytecode.PUTSTATIC) {
	
>>>>>More tweaks to :/ClassFileReader.java:(3985409, 3989505)>>>>>
			if(opcode == Bytecode.GETSTATIC) {
	
------------------------------------
-----Bug fix for par:/Bytecode.java:(1409025, 1413121)-----
			} else if(constant instanceof JvmType.Reference) {
	
>>>>>Fixed another b:/Bytecode.java:(1409025, 1413121)>>>>>
			} else if(constant instanceof JvmType) {
	
------------------------------------
Git diff =0  Refactor Categories =61

REFACTOR CATEGORIES:COMMENT:DELETE
-----support for -s :/Program.java:(495646, 499713)-----

	
>>>>>Update READM:/Program.java:(434206, 438273)>>>>>
 /* Do *NOT* use canonical path */
	
------------------------------------
Git diff =0  Refactor Categories =1

REFACTOR CATEGORIES:COMMENT:INSERT
-----java 6 instead :/Program.java:(905217, 909313)-----
        //procBuilder.inheritIO();
 
>>>>>make with gcj, :/Program.java:(823297, 823304)>>>>>
        
------------------------------------
Git diff =0  Refactor Categories =1

REFACTOR CATEGORIES:COMMENT:MODIFY
-----mis:/Program.java:(126977, 131073)-----
 * @author  Mattias Andrée, <a href="mailto:maandree@member.fsf.org">maandree@member.fsf.org</a>
 
>>>>>Update READM:/Program.java:(126977, 131073)>>>>>
 * @author  Mattias Andrée, <a href="mailto:maandree+jpp@kth.se">maandree+jpp@kth.se</a>
 
------------------------------------
-----m do:/Program.java:(102401, 106497)-----
/* Compilers and preprocessors SHOULD NEVER use canonical paths. (except for maybe inclusing guarding) */


>>>>>Merge branch 'm:/Program.java:(102401, 106497)>>>>>
/* Compilers and preprocessors SHOULD NEVER use canonical paths. */


------------------------------------
-----support for -s :/Program.java:(307208, 307211)-----
if (
>>>>>Update READM:/Program.java:(290824, 290827)>>>>>
if (
------------------------------------
Git diff =0  Refactor Categories =4

REFACTOR CATEGORIES:WHITESPACE:MODIFY
-----ignore <""> dur:/Program.java:(901173, 905219)-----

			
>>>>>portablilit:/Program.java:(876655, 880641)>>>>>

	
------------------------------------
-----support for -s :/Program.java:(495617, 495618)-----
		
>>>>>Update READM:/Program.java:(434177, 434178)>>>>>
		
------------------------------------
-----test case + fix:/Program.java:(761891, 765958)-----

		    
>>>>>der:/Program.java:(753705, 757761)>>>>>

	
------------------------------------
Git diff =0  Refactor Categories =5

REFACTOR CATEGORIES:JAVA:DELETE
-----fix make file +:/Program.java:(458758, 462863)-----
if (sFlag.endsWith("/") == false)
		sFlag += "/";
>>>>>improve makefil:/Program.java:(475137, 479233)>>>>>
		String _file = absolute(file).substring(sFlag.length());
	
------------------------------------
-----fix make file +:/Program.java:(466950, 487425)-----
for (final String file : files)
	    {
		String _file = file;
		if (_file.startsWith(sFlag))
		    _file = _file.substring(sFlag.length());
	
>>>>>improve makefil:/Program.java:(475137, 479233)>>>>>
		String _file = absolute(file).substring(sFlag.length());
	
------------------------------------
-----test case + fix:/Program.java:(937986, 938014)-----
String exec = output + ".sh";
>>>>>der:/Program.java:(909321, 909416)>>>>>
final ProcessBuilder procBuilder = new ProcessBuilder(("bash ./" + output + ".sh").split("\0"));
------------------------------------
Git diff =0  Refactor Categories =9

REFACTOR CATEGORIES:JAVA:INSERT
-----postprocessin:/Program.java:(782347, 782366)-----
"echo '" + lineIndex
>>>>>javac make subs:/Program.java:(774155, 774163)>>>>>
lineIndex
------------------------------------
-----postprocessin:/Program.java:(782370, 782372)-----
" "
>>>>>javac make subs:/Program.java:(774167, 774175)>>>>>
" echo '"
------------------------------------
Git diff =0  Refactor Categories =2

GIT DIFF:JAVA:MODIFY
====================================
-----ignore <""> dur:/Program.java:(901121, 909313)-----
			data = data.replace("<\"\">", debug ? "" : "//");
			data = data.replace("'", "'\\''").replace("<\"$", "'\"${").replace("$\">", "}\"'");
	
>>>>>portablilit:/Program.java:(876545, 880641)>>>>>
			data = data.replace("<\"\">", "//").replace("'", "'\\''").replace("<\"$", "'\"${").replace("$\">", "}\"'");
	
------------------------------------
-----portablilit:/Program.java:(614401, 630785)-----
	final String ucs = "\033[00;01;3" + colour + "mjpp\033[36m:\033[3" + colour + "m" + _type + "\033[36m:\033[00m"
	                 + (_file == null ? "" : "\033[35m" + _file + "\033[36m:\033[00m")
	                 + (_location == null ? "" : "\033[32m" + _location.replace(":", "\033[36m:\033[32m") + "\033[36m:\033[00m")
	                 + _description.replace(":", "\033[36m:\033[34m") + "\033[00m";
	
>>>>>update dis:/Program.java:(614401, 630785)>>>>>
	final String ucs = "\033[0;1;3" + colour + "mjpp\033[36m:\033[3" + colour + "m" + _type + "\033[36m:\033[21;39m"
	                 + (_file == null ? "" : "\033[35m" + _file + "\033[36m:\033[39m")
	                 + (_location == null ? "" : "\033[32m" + _location.replace(":", "\033[36m:\033[32m") + "\033[36m:\033[39m")
	                 + _description.replace(":", "\033[36m:\033[34m") + "\033[0m";
	
------------------------------------
-----portablilit:/Program.java:(659457, 663553)-----
		    ascii.append("\033[02m\\0");
	
>>>>>update dis:/Program.java:(659457, 663553)>>>>>
		    ascii.append("\033[2m\\0");
	
------------------------------------

REFACTOR CATEGORIES:JAVA:MODIFY
-----ignore <""> dur:/Program.java:(901131, 901171)-----
data.replace("<\"\">", debug ? "" : "//")
>>>>>portablilit:/Program.java:(876555, 876653)>>>>>
data.replace("<\"\">", "//").replace("'", "'\\''").replace("<\"$", "'\"${").replace("$\">", "}\"'")
------------------------------------
-----portablilit:/Program.java:(614402, 626768)-----
final String ucs = "\033[00;01;3" + colour + "mjpp\033[36m:\033[3" + colour + "m" + _type + "\033[36m:\033[00m"
	                 + (_file == null ? "" : "\033[35m" + _file + "\033[36m:\033[00m")
	                 + (_location == null ? "" : "\033[32m" + _location.replace(":", "\033[36m:\033[32m") + "\033[36m:\033[00m")
	                 + _description.replace(":", "\033[36m:\033[34m") + "\033[00m";
>>>>>update dis:/Program.java:(614402, 626767)>>>>>
final String ucs = "\033[0;1;3" + colour + "mjpp\033[36m:\033[3" + colour + "m" + _type + "\033[36m:\033[21;39m"
	                 + (_file == null ? "" : "\033[35m" + _file + "\033[36m:\033[39m")
	                 + (_location == null ? "" : "\033[32m" + _location.replace(":", "\033[36m:\033[32m") + "\033[36m:\033[39m")
	                 + _description.replace(":", "\033[36m:\033[34m") + "\033[0m";
------------------------------------
-----portablilit:/Program.java:(659476, 659484)-----
"\033[02m
>>>>>update dis:/Program.java:(659476, 659483)>>>>>
"\033[2m
------------------------------------
Git diff =41  Refactor Categories =45

REFACTOR CATEGORIES:JAVA:RENAMED
-----der:/Program.java:(987141, 991233)-----
public static void postprocess(final String input, final String output) throws Throwable
 
>>>>>postprocessin:/Program.java:(987141, 991233)>>>>>
public static void process(final String input, final String output) throws Throwable
 
------------------------------------
-----if nothing is w:/Program.java:(180226, 180276)-----
final HashSet<String>  fileSet = new   HashSet<>();
>>>>>program bas:/Program.java:(167938, 167993)>>>>>
final ArrayList<String> files = new ArrayList<String>();
------------------------------------
Git diff =0  Refactor Categories =2

REFACTOR CATEGORIES:JAVA:EQUIVALENT
-----test case + fix:/Program.java:(790529, 794625)-----
			out.write((trim + line.substring(line.startsWith("#!") ? 0 : 1)).getBytes("UTF-8"));
	
>>>>>der:/Program.java:(761857, 765953)>>>>>
			out.write(line.substring(1).getBytes("UTF-8"));
	
------------------------------------
Git diff =0  Refactor Categories =1

REFACTOR CATEGORIES:COMMENT:DELETE
-----Project test wo:/JavaASTParser.java:(299009, 299010)-----
		
>>>>>Package parse:/JavaASTParser.java:(299009, 303106)>>>>>
		// TODO Auto-generated method stub
		
------------------------------------
-----Package parse:/JavaASTParser.java:(221185, 221186)-----
		
>>>>>Changes in pars:/JavaASTParser.java:(217089, 221186)>>>>>
		// TODO Auto-generated method stub
		
------------------------------------
Git diff =0  Refactor Categories =2

REFACTOR CATEGORIES:COMMENT:MODIFY
-----Refactoring imp:/NodeImpl.java:(4097, 8193)-----
package com.klangner.ast.impl;


>>>>>File is Compila:/NodeImpl.java:(4097, 8193)>>>>>
package com.klangner.ast.java;


------------------------------------
-----Stworzenie jako:/JavaBaseListener.java:(8193, 12289)-----
package com.klangner.ast.java.grammar;


>>>>>Refactorin:/JavaBaseListener.java:(8193, 12289)>>>>>
package com.klangner.entropy.parser.java;


------------------------------------
-----Stworzenie jako:/JavaASTParserTest.java:(4097, 8193)-----
package com.klangner.ast.java;


>>>>>Refactorin:/ASTParserTest.java:(4097, 8193)>>>>>
package com.klangner.entropy.parser;


------------------------------------
Git diff =0  Refactor Categories =5

REFACTOR CATEGORIES:WHITESPACE:MODIFY
-----Parse import de:/ASTBuilder.java:(102460, 106498)-----

		
>>>>>Parsing java fi:/ASTBuilder.java:(102457, 106497)>>>>>

	
------------------------------------
-----File is Compila:/JavaASTParser.java:(401501, 405505)-----

	
>>>>>Datasets moved :/JavaASTParser.java:(389148, 393221)>>>>>

					
------------------------------------
-----Changes in pars:/JavaASTParser.java:(110639, 118792)-----


        
>>>>>renamed maven p:/JavaASTParser.java:(81973, 86017)>>>>>

 
------------------------------------
Git diff =0  Refactor Categories =5

REFACTOR CATEGORIES:JAVA:DELETE
-----New functions i:/JavaASTParser.java:(339971, 340006)-----
String subPackageName = packageName;
>>>>>updated after s:/JavaASTParser.java:(339971, 348161)>>>>>
if(!packageName.isEmpty()){
			packageName += ".";
	
------------------------------------
-----New functions i:/JavaASTParser.java:(344067, 352257)-----
if(!subPackageName.isEmpty()){
			subPackageName += ".";
	
>>>>>updated after s:/JavaASTParser.java:(339971, 348161)>>>>>
if(!packageName.isEmpty()){
			packageName += ".";
	
------------------------------------
-----File is Compila:/ASTBuilder.java:(102403, 102413)-----
currentNode
>>>>>Datasets moved :/ASTBuilder.java:(73731, 73738)>>>>>
rootNode
------------------------------------
Git diff =0  Refactor Categories =19

REFACTOR CATEGORIES:JAVA:INSERT
-----File is Compila:/ASTBuilder.java:(102403, 102413)-----
currentNode
>>>>>Datasets moved :/ASTBuilder.java:(73731, 73738)>>>>>
rootNode
------------------------------------
-----File is Compila:/ASTBuilder.java:(102417, 102420)-----
node
>>>>>Datasets moved :/ASTBuilder.java:(73742, 73781)>>>>>
new NodeImpl(ctx.Identifier().getText())
------------------------------------
-----File is Compila:/JavaASTParser.java:(401414, 401500)-----
INode node = parseProjectDirectory(file.getAbsolutePath(), packageName+file.getName());
>>>>>Datasets moved :/JavaASTParser.java:(389126, 389147)>>>>>
String subPackageName;
------------------------------------
Git diff =0  Refactor Categories =5

GIT DIFF:JAVA:MODIFY
====================================
-----New functions i:/ImportImpl.java:(28673, 81921)-----
	public ImportImpl(String text) {
		super(text);
	}

	@Override
	public String getPackageName() {
		String name = getText();
		
		int index = name.lastIndexOf('.');
		if(index >= 0){
			name = name.substring(0, index);
		}
		return name;
	
>>>>>updated after s:/ImportImpl.java:(28673, 36865)>>>>>
	public ImportImpl(String name) {
		super(name);
	
------------------------------------
-----New functions i:/ModuleImpl.java:(28673, 73729)-----
	private String name;
	
	
	public ModuleImpl(String text, String name) {
		super(text);
		this.name = name;
	}

	@Override
	public String getName() {
		return name;
	
>>>>>updated after s:/ModuleImpl.java:(28673, 36865)>>>>>
	public ModuleImpl(String name) {
		super(name);
	
------------------------------------
-----New functions i:/JavaASTParser.java:(339969, 352257)-----
		String subPackageName = packageName;
		if(!subPackageName.isEmpty()){
			subPackageName += ".";
	
>>>>>updated after s:/JavaASTParser.java:(339969, 348161)>>>>>
		if(!packageName.isEmpty()){
			packageName += ".";
	
------------------------------------

REFACTOR CATEGORIES:JAVA:MODIFY
-----New functions i:/ModuleImpl.java:(28674, 28693)-----
private String name;
>>>>>updated after s:/ModuleImpl.java:(28674, 36865)>>>>>
public ModuleImpl(String name) {
		super(name);
	
------------------------------------
-----New functions i:/JavaASTParser.java:(397319, 397384)-----
INode node = parseModuleFile(file.getAbsolutePath(), packageName);
>>>>>updated after s:/JavaASTParser.java:(393223, 393275)>>>>>
INode node = parseModuleFile(file.getAbsolutePath());
------------------------------------
-----New functions i:/JavaASTParser.java:(417798, 417887)-----
INode node = parseProjectDirectory(file.getAbsolutePath(), subPackageName+file.getName());
>>>>>updated after s:/JavaASTParser.java:(413702, 413788)>>>>>
INode node = parseProjectDirectory(file.getAbsolutePath(), packageName+file.getName());
------------------------------------
Git diff =85  Refactor Categories =37

REFACTOR CATEGORIES:JAVA:RENAMED
-----updated after s:/NodeImpl.java:(77825, 81921)-----
	public String getText() {
	
>>>>>fixed project n:/NodeImpl.java:(77825, 81921)>>>>>
	public String getName() {
	
------------------------------------
-----Parse import:/FileParserTest.java:(241665, 253953)-----
			if(ast.getChild(0) instanceof IImport){
				importNode = (IImport) ast.getChild(0);
				break;
	
>>>>>Parse import de:/FileParserTest.java:(163841, 167937)>>>>>
			System.out.println(ast.getChild(i));
	
------------------------------------
-----Correctly reads:/JavaASTParser.java:(364545, 368641)-----
					else if(file.getName().equals("module.info")){
	
>>>>>Project test wo:/JavaASTParser.java:(348161, 356353)>>>>>
				}
				else{
	
------------------------------------
Git diff =0  Refactor Categories =20

REFACTOR CATEGORIES:JAVA:EQUIVALENT
-----New functions i:/ImportImpl.java:(28673, 81921)-----
	public ImportImpl(String text) {
		super(text);
	}

	@Override
	public String getPackageName() {
		String name = getText();
		
		int index = name.lastIndexOf('.');
		if(index >= 0){
			name = name.substring(0, index);
		}
		return name;
	
>>>>>updated after s:/ImportImpl.java:(28673, 36865)>>>>>
	public ImportImpl(String name) {
		super(name);
	
------------------------------------
-----updated after s:/ProjectParserTest.java:(188417, 192513)-----
		if(node1.getText().equals("impl1")){
	
>>>>>fixed project n:/ProjectParserTest.java:(188417, 192513)>>>>>
		if(node1.getName().equals("impl1")){
	
------------------------------------
-----updated after s:/ProjectParserTest.java:(299009, 303105)-----
		if(ast.getChild(0).getText().equals("impl2")){
	
>>>>>fixed project n:/ProjectParserTest.java:(299009, 303105)>>>>>
		if(ast.getChild(0).getName().equals("impl2")){
	
------------------------------------
Git diff =0  Refactor Categories =21

REFACTOR CATEGORIES:COMMENT:DELETE
-----Fixed issue #57:/CircularReferenceDetector.java:(110593, 126977)-----
	/**
	 * It would be better to use <code>java.util.Deque</code> instead of the linked list, but that was first
	 * introduced in Java 6 and would break compatibility with Java 5.
	 */
	
>>>>>Removed unneces:/CircularReferenceDetector.java:(110653, 114689)>>>>>



------------------------------------
-----Refactored Bean:/BeanDifferShould.java:(573443, 577537)-----



>>>>>Refactored Bean:/BeanDifferShould.java:(434177, 565249)>>>>>
//	@Test
//	public void introspect_introspectible_beans()
//	{
//		accessor = mock(Accessor.class);
//
//		final Instances propertyInstances = mock(Instances.class);
//		instances = mock(Instances.class);
//		doReturn(accessor).when(instances).getSourceAccessor();
//		doReturn(ObjectWithIdentityAndValue.class).when(instances).getType();
//		doReturn(propertyInstances).when(instances).access(accessor);
//
//		configuration = mock(Configuration.class);
//		doReturn(true).when(configuration).isIntrospectible(any(DefaultNode.class));
//
//		delegator = mock(DifferDelegator.class);
//
//		differ = new BeanDiffer(delegator, configuration);
//		differ.setIntrospector(introspector);
//
//		when(introspector.introspect(ObjectWithIdentityAndValue.class)).thenReturn(asList(accessor));
//
//		final Node node = differ.compare(Node.ROOT, instances);
//
//		verify(introspector).introspect(ObjectWithIdentityAndValue.class);
//	}
//
//	@AfterMethod
//	public void tearDown() throws Exception
//	{
//		final MockitoDebugger debugger = new MockitoDebuggerImpl();
//		debugger.printInvocations(instances, configuration, delegator, introspector, accessor);
//	}


------------------------------------
-----Refactored Bean:/BeanDifferShould.java:(180245, 184321)-----

	
>>>>>Simplified Diff:/BeanDifferShould.java:(155668, 155669)>>>>>
) 
------------------------------------
Git diff =0  Refactor Categories =9

REFACTOR CATEGORIES:COMMENT:INSERT
-----Made adjustment:/InclusionService.java:(618497, 634882)-----
//		else if (node.getParentNode() != null && typeInclusions.get(node.getParentNode().getValueType()) == INCLUDED)
//		{
//			return true;
//		}
		
>>>>>[maven-release-:/InclusionService.java:(684038, 688130)>>>>>

		
------------------------------------
-----Major refactori:/ObjectDifferIntegrationTests.java:(450641, 458753)-----

		// final Configuration2 configuration = new Configuration2().withChildrenOfAddedNodes();


>>>>>Update README.m:/ObjectDifferIntegrationTests.java:(434262, 438273)>>>>>



------------------------------------
-----Fixed issue #57:/CircularReferenceDetector.java:(110593, 126977)-----
	/**
	 * It would be better to use <code>java.util.Deque</code> instead of the linked list, but that was first
	 * introduced in Java 6 and would break compatibility with Java 5.
	 */
	
>>>>>Removed unneces:/CircularReferenceDetector.java:(110653, 114689)>>>>>



------------------------------------
Git diff =0  Refactor Categories =15

REFACTOR CATEGORIES:COMMENT:MODIFY
-----Made adjustment:/InclusionService.java:(385028, 385031)-----
if (
>>>>>[maven-release-:/InclusionService.java:(393220, 393223)>>>>>
if (
------------------------------------
-----Made adjustment:/InclusionService.java:(385054, 389121)-----
)
	
>>>>>[maven-release-:/InclusionService.java:(393241, 397315)>>>>>
)
			
------------------------------------
-----Polishing and i:/PropertyAccessException.java:(118787, 118819)-----
rotected PropertyAccessException(
>>>>>Simplified Intr:/PropertyAccessException.java:(118787, 118816)>>>>>
ublic PropertyAccessException(
------------------------------------
Git diff =0  Refactor Categories =1069

REFACTOR CATEGORIES:WHITESPACE:MODIFY
-----Polishing and i:/DefaultPropertyAccessExceptionHandler.java:(118823, 122881)-----

	
>>>>>Simplified Intr:/DefaultPropertyAccessExceptionHandler.java:(118835, 122882)>>>>>

		
------------------------------------
-----Polishing and i:/PropertyAccessException.java:(118896, 122881)-----

	
>>>>>Simplified Intr:/PropertyAccessException.java:(118839, 122881)>>>>>

	
------------------------------------
-----Renamed 'config:/ObjectDifferIT.java:(552961, 552962)-----
		
>>>>>Made the config:/ObjectDifferIT.java:(552961, 552962)>>>>>
		
------------------------------------
Git diff =0  Refactor Categories =227

REFACTOR CATEGORIES:JAVA:DELETE
-----Polishing and i:/PropertyAccessException.java:(118820, 118844)-----
final String propertyName
>>>>>Simplified Intr:/PropertyAccessException.java:(118817, 118837)>>>>>
final Throwable cause
------------------------------------
-----Polishing and i:/PropertyAccessException.java:(118847, 118871)-----
final Class<?> targetType
>>>>>Simplified Intr:/PropertyAccessException.java:(118817, 118837)>>>>>
final Throwable cause
------------------------------------
-----Polishing and i:/PropertyAccessException.java:(118874, 118894)-----
final Throwable cause
>>>>>Simplified Intr:/PropertyAccessException.java:(118817, 118837)>>>>>
final Throwable cause
------------------------------------
Git diff =0  Refactor Categories =640

REFACTOR CATEGORIES:JAVA:INSERT
-----Made adjustment:/InclusionService.java:(634883, 634895)-----
return false;
>>>>>[maven-release-:/InclusionService.java:(675841, 684037)>>>>>
				}
			}
		});
------------------------------------
-----Made adjustment:/InclusionService.java:(634883, 634895)-----
return false;
>>>>>[maven-release-:/InclusionService.java:(688131, 712707)>>>>>
if (node.getValueType() != null)
		{
			if (typeInclusions.get(node.getValueType()) == INCLUDED)
			{
				result.set(true);
			}
		}
------------------------------------
-----Made adjustment:/InclusionService.java:(634883, 634895)-----
return false;
>>>>>[maven-release-:/InclusionService.java:(716803, 716822)>>>>>
return result.get();
------------------------------------
Git diff =0  Refactor Categories =593

GIT DIFF:JAVA:MODIFY
====================================
-----Made adjustment:/InclusionService.java:(385025, 389121)-----
			if (isExcludedByPath(node))
	
>>>>>[maven-release-:/InclusionService.java:(393217, 413697)>>>>>
			if (node.isExcluded())
			{
				return true;
			}
			else if (isExcludedByPath(node))
	
------------------------------------
-----Made adjustment:/InclusionService.java:(610305, 614401)-----
			return true;
	
>>>>>[maven-release-:/InclusionService.java:(663553, 671745)>>>>>
						result.set(true);
						visit.stop();
	
------------------------------------
-----Made adjustment:/InclusionService.java:(618497, 638977)-----
//		else if (node.getParentNode() != null && typeInclusions.get(node.getParentNode().getValueType()) == INCLUDED)
//		{
//			return true;
//		}
		return false;
	
>>>>>[maven-release-:/InclusionService.java:(675841, 720897)>>>>>
				}
			}
		});
		if (node.getValueType() != null)
		{
			if (typeInclusions.get(node.getValueType()) == INCLUDED)
			{
				result.set(true);
			}
		}
		return result.get();
	
------------------------------------

REFACTOR CATEGORIES:JAVA:MODIFY
-----Made adjustment:/InclusionService.java:(385032, 385053)-----
isExcludedByPath(node)
>>>>>[maven-release-:/InclusionService.java:(393224, 393240)>>>>>
node.isExcluded()
------------------------------------
-----Made adjustment:/InclusionService.java:(610305, 614401)-----
			return true;
	
>>>>>[maven-release-:/InclusionService.java:(663553, 671745)>>>>>
						result.set(true);
						visit.stop();
	
------------------------------------
-----Polishing and i:/DefaultPropertyAccessExceptionHandler.java:(102402, 102486)-----
Logger logger = LoggerFactory.getLogger(DefaultPropertyAccessExceptionHandler.class);
>>>>>Simplified Intr:/DefaultPropertyAccessExceptionHandler.java:(102402, 102507)>>>>>
private static final Logger logger = LoggerFactory.getLogger(DefaultPropertyAccessExceptionHandler.class);
------------------------------------
Git diff =8219  Refactor Categories =5240

REFACTOR CATEGORIES:JAVA:RENAMED
-----Polishing and i:/PropertyAccessor.java:(520202, 520222)-----
final Exception cause
>>>>>Simplified Intr:/PropertyAccessor.java:(520202, 520218)>>>>>
final Exception e
------------------------------------
-----Polishing and i:/PropertyAccessor.java:(765962, 765982)-----
final Exception cause
>>>>>Simplified Intr:/PropertyAccessor.java:(774154, 774170)>>>>>
final Exception e
------------------------------------
-----Simplified Intr:/CategoryAware.java:(106498, 106539)-----
Set<String> getCategoriesFromAnnotation();
>>>>>Rewrote tests f:/CategoryAware.java:(106498, 106525)>>>>>
Set<String> getCategories();
------------------------------------
Git diff =0  Refactor Categories =2702

REFACTOR CATEGORIES:JAVA:EQUIVALENT
-----Polishing and i:/PropertyAccessException.java:(131073, 139265)-----
		this.propertyName = propertyName;
		this.targetType = targetType;
	
>>>>>Simplified Intr:/PropertyAccessException.java:(131073, 155649)>>>>>
	}

	@Override
	public String getMessage()
	{
		return String.format("Property '%s' on target of type %s.", propertyName, targetType);
	
------------------------------------
-----Polishing and i:/PropertyAccessor.java:(696321, 700417)-----
		}
	
>>>>>Simplified Intr:/PropertyAccessor.java:(704513, 708609)>>>>>

	
------------------------------------
-----Polishing and i:/PropertyAccessor.java:(724993, 729089)-----
		}
	
>>>>>Simplified Intr:/PropertyAccessor.java:(733185, 737281)>>>>>

	
------------------------------------
Git diff =0  Refactor Categories =825

REFACTOR CATEGORIES:COMMENT:DELETE
-----Moved Lines cla:/TestMethodCodeByStatement.java:(311297, 311304)-----
        
>>>>>Added Delta cla:/TestMethodCodeByStatement.java:(344065, 348161)>>>>>
        // dump(methBlk);


------------------------------------
-----Added compariso:/Initializer.java:(57345, 57348)-----
    
>>>>>Added compariso:/Initializer.java:(36865, 65537)>>>>>
    // public static final Message METHOD_REMOVED = new Message("method removed: {0}");
    // public static final Message METHOD_ADDED = new Message("method added: {0}");
    // public final static Messages METHOD_MSGS = new Messages(METHOD_ADDED, null, METHOD_REMOVED);

    // public static final Message RETURN_TYPE_CHANGED = new Message("return type changed from {0} to {1}");
    // public static final Message METHOD_BLOCK_ADDED = new Message("method block added");
    // public static final Message METHOD_BLOCK_REMOVED = new Message("method block removed");


------------------------------------
-----Added compariso:/Initializer.java:(77825, 77828)-----
    
>>>>>Added compariso:/Initializer.java:(73729, 81921)>>>>>
    // private final Block block;
    // private final String name;


------------------------------------
Git diff =0  Refactor Categories =29

REFACTOR CATEGORIES:COMMENT:INSERT
-----Added compariso:/Type.java:(622593, 634881)-----
        // Items<Field, ASTFieldDeclaration> fromFields = getFields();
        // Items<Field, ASTFieldDeclaration> toFields = toType.getFields();
        // fromFields.diff(toFields, differences);
 
>>>>>Refactored Toke:/Type.java:(552961, 552968)>>>>>
        
------------------------------------
-----Added compariso:/Type.java:(638977, 651265)-----
        // Items<Ctor, ASTConstructorDeclaration> fromCtors = getCtors();
        // Items<Ctor, ASTConstructorDeclaration> toCtors = toType.getCtors();
        // fromCtors.diff(toCtors, differences);
 
>>>>>Refactored Toke:/Type.java:(569345, 569352)>>>>>
        
------------------------------------
-----Another interme:/Block.java:(397313, 413697)-----
        // LocationRange fromLocRg = alist.getLocationRange(df.getDeletedStart(), df.getDeletedEnd());
        // tr.Ace.log("fromLocRg", fromLocRg);
        // LocationRange toLocRg = blist.getLocationRange(df.getAddedStart(), df.getAddedEnd());
        // tr.Ace.log("toLocRg", toLocRg);


>>>>>Intermediate ch:/Block.java:(352257, 352264)>>>>>
        
------------------------------------
Git diff =0  Refactor Categories =38

REFACTOR CATEGORIES:COMMENT:MODIFY
-----Moved Lines cla:/Lines.java:(4097, 8193)-----
package org.incava.diffj.util;


>>>>>Added Delta cla:/Lines.java:(4097, 8193)>>>>>
package org.incava.diffj;


------------------------------------
-----Refactored Stat:/StatementListDifferenceChange.java:(45177, 49160)-----
{
        
>>>>>More refactorin:/StatementListDifferenceChange.java:(45157, 49153)>>>>>
{
 
------------------------------------
-----More migration :/StatementListDiffer.java:(32853, 36868)-----
{
    
>>>>>Refined getAsTo:/StatementListDiffer.java:(28757, 32772)>>>>>
{
    
------------------------------------
Git diff =0  Refactor Categories =135

REFACTOR CATEGORIES:WHITESPACE:MODIFY
-----Merge branch 'm:/Tkn.java:(159754, 167944)-----

        
        
>>>>>Removed unused :/Tkn.java:(172128, 176129)>>>>>

 
------------------------------------
-----Added Delta cla:/Tkn.java:(172128, 176129)-----

 
>>>>>Refactored Toke:/Tkn.java:(159754, 167944)>>>>>

        
        
------------------------------------
-----Refactored Toke:/Tkn.java:(159754, 167944)-----

        
        
>>>>>Refactored Stat:/Tkn.java:(172128, 176129)>>>>>

 
------------------------------------
Git diff =0  Refactor Categories =253

REFACTOR CATEGORIES:JAVA:DELETE
-----Merge branch 'm:/Tkn.java:(139273, 159753)-----
if (token == null) {
            return other.token == null ? 0 : -1;
        }
        else if (other.token == null) {
            return 1;
        }
>>>>>Removed unused :/Tkn.java:(172041, 172127)>>>>>
int cmp = token.kind < other.token.kind ? -1 : (token.kind > other.token.kind ? 1 : 0);
------------------------------------
-----Merge branch 'm:/Tkn.java:(167945, 168019)-----
int cmp = new Integer(token.kind).compareTo(new Integer(other.token.kind));
>>>>>Removed unused :/Tkn.java:(172041, 172127)>>>>>
int cmp = token.kind < other.token.kind ? -1 : (token.kind > other.token.kind ? 1 : 0);
------------------------------------
-----Refactored Toke:/Tkn.java:(139273, 159753)-----
if (token == null) {
            return other.token == null ? 0 : -1;
        }
        else if (other.token == null) {
            return 1;
        }
>>>>>Refactored Stat:/Tkn.java:(172041, 172127)>>>>>
int cmp = token.kind < other.token.kind ? -1 : (token.kind > other.token.kind ? 1 : 0);
------------------------------------
Git diff =0  Refactor Categories =1581

REFACTOR CATEGORIES:JAVA:INSERT
-----Added Delta cla:/Tkn.java:(172041, 172127)-----
int cmp = token.kind < other.token.kind ? -1 : (token.kind > other.token.kind ? 1 : 0);
>>>>>Refactored Toke:/Tkn.java:(139273, 159753)>>>>>
if (token == null) {
            return other.token == null ? 0 : -1;
        }
        else if (other.token == null) {
            return 1;
        }
------------------------------------
-----Added Delta cla:/Tkn.java:(172041, 172127)-----
int cmp = token.kind < other.token.kind ? -1 : (token.kind > other.token.kind ? 1 : 0);
>>>>>Refactored Toke:/Tkn.java:(167945, 168019)>>>>>
int cmp = new Integer(token.kind).compareTo(new Integer(other.token.kind));
------------------------------------
-----Refactored Stat:/StatementListDifference.java:(73737, 73793)-----
process(name, fromStatements, toStatements, differences);
>>>>>More refactorin:/StatementListDifference.java:(73737, 73823)>>>>>
TokenList fromList = fromStatements.getAsTokenList(getDeletedStart(), getDeletedEnd());
------------------------------------
Git diff =0  Refactor Categories =1396

GIT DIFF:JAVA:MODIFY
====================================
-----Made compliant :/Diffable.java:(36865, 40961)-----
public interface Diffable<DiffType extends Diffable<DiffType>> {
 
>>>>>Merge branch 'm:/Diffable.java:(36865, 40961)>>>>>
public interface Diffable<DiffType extends Diffable> {
 
------------------------------------
-----Made compliant :/ParameterTypes.java:(118785, 122881)-----
        ListComparator<String> lc = new ListComparator<String>(paramTypes, toParamTypes);


>>>>>Merge branch 'm:/ParameterTypes.java:(118785, 122881)>>>>>
        ListComparator lc = new ListComparator<String>(paramTypes, toParamTypes);


------------------------------------
-----Made compliant :/TypeMatches.java:(45057, 49153)-----
import org.incava.ijdk.lang.NCPair;
i
>>>>>Merge branch 'm:/TypeMatches.java:(45057, 49153)>>>>>
import org.incava.ijdk.lang.Pair;
i
------------------------------------

REFACTOR CATEGORIES:JAVA:MODIFY
-----Made compliant :/ParameterTypes.java:(118793, 118873)-----
ListComparator<String> lc = new ListComparator<String>(paramTypes, toParamTypes);
>>>>>Merge branch 'm:/ParameterTypes.java:(118793, 118865)>>>>>
ListComparator lc = new ListComparator<String>(paramTypes, toParamTypes);
------------------------------------
-----Made compliant :/TypeMatches.java:(61476, 61508)-----
NCPair<ElementType, ElementType>>
>>>>>Merge branch 'm:/TypeMatches.java:(61476, 61506)>>>>>
Pair<ElementType, ElementType>>
------------------------------------
-----Made compliant :/TypeMatches.java:(86025, 86036)-----
this.matches
>>>>>Merge branch 'm:/TypeMatches.java:(86025, 86036)>>>>>
this.matches
------------------------------------
Git diff =3544  Refactor Categories =2727

REFACTOR CATEGORIES:JAVA:MOVE
-----Midstream on re:/StatementListDiffer.java:(159825, 159832)-----
delStart
>>>>>Refactored Type:/StatementListDiffer.java:(159815, 159822)>>>>>
delStart
------------------------------------
-----Midstream on re:/StatementListDiffer.java:(172116, 172123)-----
delStart
>>>>>Refactored Type:/StatementListDiffer.java:(172106, 172113)>>>>>
delStart
------------------------------------
-----Midstream on re:/StatementListDiffer.java:(184404, 184411)-----
delStart
>>>>>Refactored Type:/StatementListDiffer.java:(184394, 184401)>>>>>
delStart
------------------------------------
Git diff =0  Refactor Categories =31

REFACTOR CATEGORIES:JAVA:RENAMED
-----Added Delta cla:/StatementListDifferenceAdd.java:(69637, 77829)-----
public FileDiff getFileDiff(String msg, LocationRange fromLocRg, LocationRange toLocRg) {
        return new FileDiffCodeAdded(msg, fromLocRg, toLocRg);
    }
>>>>>Refactored Toke:/StatementListDifferenceAdd.java:(73733, 86017)>>>>>
public void process(String name, StatementList fromStatements, StatementList toStatements, Differences differences) {
        LocationRange flr = fromStatements.getRangeAt(getDeletedStart());
        LocationRange tlr = toStatements.getRangeOf(getAddedStart(), getAddedEnd());


------------------------------------
-----Added Delta cla:/StatementListDifferenceAdd.java:(86021, 94213)-----
public LocationRange getFromRange(StatementList fromStatements) {
        return fromStatements.getRangeAt(getDeletedStart());
    }
>>>>>Refactored Toke:/StatementListDifferenceAdd.java:(90113, 102401)>>>>>
        String msg = getMessage(name);        
        FileDiff fileDiff = new FileDiffCodeAdded(msg, flr, tlr);
        differences.add(fileDiff);
 
------------------------------------
-----Added Delta cla:/StatementListDifferenceDelete.java:(69637, 77829)-----
public FileDiff getFileDiff(String msg, LocationRange fromLocRg, LocationRange toLocRg) {
        return new FileDiffCodeDeleted(msg, fromLocRg, toLocRg);
    }
>>>>>Refactored Toke:/StatementListDifferenceDelete.java:(73733, 86017)>>>>>
public void process(String name, StatementList fromStatements, StatementList toStatements, Differences differences) {
        LocationRange flr = fromStatements.getRangeOf(getDeletedStart(), getDeletedEnd());
        LocationRange tlr = toStatements.getRangeAt(getAddedStart());


------------------------------------
Git diff =0  Refactor Categories =1068

REFACTOR CATEGORIES:JAVA:EQUIVALENT
-----Made compliant :/Diffable.java:(36865, 40961)-----
public interface Diffable<DiffType extends Diffable<DiffType>> {
 
>>>>>Merge branch 'm:/Diffable.java:(36865, 40961)>>>>>
public interface Diffable<DiffType extends Diffable> {
 
------------------------------------
-----Made compliant :/TypeMatches.java:(45057, 49153)-----
import org.incava.ijdk.lang.NCPair;
i
>>>>>Merge branch 'm:/TypeMatches.java:(45057, 49153)>>>>>
import org.incava.ijdk.lang.Pair;
i
------------------------------------
-----Made compliant :/TypeMatches.java:(159745, 163841)-----
    public Collection<NCPair<ElementType, ElementType>> get(double score) {
 
>>>>>Merge branch 'm:/TypeMatches.java:(159745, 163841)>>>>>
    public Collection<Pair<ElementType, ElementType>> get(double score) {
 
------------------------------------
Git diff =0  Refactor Categories =465


% need the results in here
% 
% 
% what this means
% modifications to comments
% 
% modification to comments could be surplus to need
% 
% 
% Examine certain events
% 
% in this case the comment is removed but as the comment is associated with a 
% functional change the comment also needs to change in both versions



% Gitblit
% Gitblit is an open source, pure Java Git solution for managing, viewing, and 
% serving Git repositories. It can serve repositories over the GIT, HTTP, and 
% SSH transports; it can authenticate against multiple providers; and it 
% allows you to get up-and-running with an attractive, capable Git server in 
% less than 5 minutes.
% 
% More information about Gitblit can be found here. 
% https://github.com/gitblit/gitblit
% 
% 
% https://github.com/jkff/ire
% IRE
% What's this
% ire is a library for incremental regular expression matching, based on 
% further development of the ideas from Dan Piponi's famous blogpost Fast 
% Incremental Regular Expression Matching with Monoids.
% 
% ire is for "incremental", "regular", "expressions"
% incremental means "fast recomputation of results according to changes of 
% input string" (not pattern)
% regular means "regular" - t.i. no backrefs or other Perl magic.
% There is an article about it: http://jkff.info/articles/ire
% 
% 
% https://github.com/ReadyTalk/revori
% Revori - a revision-oriented DBMS
% Build Status
% 
% Revori is a database management system designed to handle rapidly-changing 
% data efficiently. In addition to traditional relational database queries, 
% Revori supports query subscriptions which allow clients to retrieve the 
% intial result of a query followed by a stream containing live updates to 
% that result.
% 
% The design is a hybrid of a relational database management system and a 
% version control system. A database is represented as an immutable revision 
% from which new revisions may be derived with data added, subtracted, or 
% replaced. These revisions may be compared with each other and/or combined 
% using a three-way merge algorithm.
% 
% For more information, see the Wiki
% 
% 
% https://github.com/JnRouvignac/AutoRefactor
% AutoRefactor
% The AutoRefactor project delivers free software that automatically refactor 
% code bases.
% 
% The aim is to fix language/API usage in order to deliver smaller, more 
% maintainable and more expressive code bases.
% 
% This is an Eclipse plugin to automatically refactor Java code bases.
% 
% License
% 
% https://github.com/robinst/git-merge-repos
% 
% git-merge-repos
% Program for merging multiple Git repositories into one, preserving previous 
% history, tags and branches.
% 
% This is useful when you had multiple repositories for one project where you 
% had the same set of branches and tags.
% 
% How it works. For each branch/tag name:
% 
% All the commits of the repositories that have this branch/tag are collected.
% The commits are merged with 1 merge commit (with N parents).
% The branch/tag is recreated on this merge commit. In case of an annotated 
% tag, the tag message and tagger information is preserved (this does not work 
% for signing information).
% 
% 



% Possible datasets
% <A HREF="https://github.com/clojure/clojure" >clojure/clojure · GitHub</A>
% A lisp like language written in Java and targeting the JVM
% <A HREF="https://github.com/rzwitserloot/lombok" >rzwitserloot/lombok · 
% GitHub</A>
% A Java library that uses annotations to simplify commonly written code
% <A HREF="https://github.com/maandree/jpp" >maandree/jpp · GitHub</A>
% A preprocessor for Java
% <A HREF="https://github.com/klangner/ast-java">klangner/ast-java · 
% GitHub</A>
% parses and represents Java as an AST
% <A HREF="https://github.com/antlr/antlr4">antlr/antlr4 · GitHub</A>
% A parser for any language you have language definition for
% 
% JaCoCo Java Code Coverage Library
% JaCoCo is a free Java code coverage library distributed under the Eclipse 
% Public License. Check http://www.eclemma.org/jacoco for downloads, 
% documentation and feedback.
% https://github.com/jacoco/jacoco
% 
% Java Object Diff
% https://github.com/SQiShER/java-object-diff
% 
% java-object-diff is a simple, yet powerful library to find differences 
% between Java objects. It takes two objects and generates a tree structure 
% that represents any differences between the objects and their children. This 
% tree can then be traversed to extract more information or apply changes to 
% the underlying data structures.
% 
% Build Status
% 
% Features
% 
% Generates an easily traversable tree structure to analyze and modify with 
% surgical precision
% Detects whether a value or item has been added, removed or changed and shows 
% the changes
% Allows to manipulate the underlying objects directly through the generated 
% tree nodes
% Works with almost any kind of object (Beans, Lists, Maps, Primitives, 
% Strings, etc.)
% Properties can be marked with category tags to easily filter for specific 
% subsets
% No configuration needed (but possible)
% No runtime dependencies except for SLF4J
% When needed, it leaves it up to you, whether you want to use declarative 
% configuration or annotations
% Getting Started
% 
% To learn how to use Java Object Diff, please have a look at the Starter 
% Guide.
% 
% Why would you need this?
% 
% Sometimes you need to figure out, how one version of an object differs from 
% another one. One of the simplest solutions that'll cross your mind is most 
% certainly to use reflection to scan the object for fields or getters and use 
% them to compare the values of the different object instances. In many cases 
% this is a perfectly valid strategy and the way to go. After all, we want to 
% keep things simple, don't we?
% 
% However, there are some cases that can increase the complexity dramatically. 
% What if you need to find differences in collections or maps? What if you 
% have to deal with nested objects that also need to be compared on a 
% per-property basis? Or even worse: what if you need to merge such objects?
% 
% You suddenly realize that you need to scan the objects recursively, figure 
% out which collection items have been added, removed or changed; find a way 
% to return your results in a way that allows you to easily access the 
% information you are looking for and provide accessors to apply changes.
% 
% While all this isn't exactly rocket science, it is complex enough to add 
% quite a lot of extra code to your project. Code that needs to be tested and 
% maintained. Since the best code is the code you didn't write, this library 
% aims to help you with all things related to diffing and merging of Java 
% objects by providing a robust foundation and a simple, yet powerful API.
% 
% This library will hide all the complexities of deep object comparison behind 
% one line of code:
% 
% Node root = ObjectDifferFactory.getInstance().compare(workingObject, 
% baseObject);
% This generates a tree structure of the given object type and lets you 
% traverse its nodes via visitors. Each node represents one property (or 
% collection item) of the underlying object and tells you exactly if and how 
% the value differs from the base version. It also provides accessors to read, 
% write and remove the value from or to any given instance. This way, all you 
% need to worry about is how to treat changes and not how to find them.
% 
% This library has been battle-tested in a rather big project of mine, where I 
% use it to generate activity streams, resolve database update conflics, 
% display change logs and limit the scope of entity updates to only a subset 
% of properties, based on the context or user permissions. It didn't let me 
% down so far and I hope that it can help you too!
% 
% Use Cases
% 
% Java Object Diff is currently used (but not limited) to...
% 
% Generate Facebook-like activity streams
% Visualize the differences between object versions
% Automatically resolve conflicts on concurrent database updates
% Detect and persist only properties that were actually changed
% Contribute
% 
% You discovered a bug or have an idea for a new feature? Great, why don't you 
% send me a Pull Request (PR) so everyone can benefit from it? To help you 
% getting started, here is a brief guide with everyting you need to know to 
% get involved!
% 
% Donate
% 
% If you’d like to support this project with a small donation, you can do so 
% via Flattr or Bitcoin.
% 
% Alternatively you could send me a nice tweet, start contributing, write a 
% blog post about this project, tell your friends about it or simply star this 
% repository. I'm happy about everything that shows me that someone out there 
% is actually using this library and appreciates all the hard work that goes 
% into its development.
% 
% https://github.com/jpace/diffj
% DiffJ
% DiffJ compares Java files based on their code, without regard to formatting, 
% organization, comments, or whitespace. Differences are reported as to the 
% precise type of change.
% 
% DiffJ was designed for comparing code when refactoring and reformatting, 
% with the differences narrowed to the extent possible, thus isolating 
% changes.
