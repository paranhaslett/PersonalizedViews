%@+leo-ver=4-thin
%@+node:paran.20140514103950.1918:@shadow theTool.tex
%@@color
%@@language latex

\chapter{Refactor categories tool}
%@<<tool desc>>
%@+node:paran.20140731173741.2006:<<tool desc>>
The refactor categories tool we have created examines the differences between files and arranges them into a greater variety of categories than used by version control systems or merge and diff tools.  In addition to being able to detect instances of delete, insert and modify the refactor categories tool can also detect instances where the code has been relocated and to some extent renamed.  It also can differentiate between changes to comments, white-space and Java code. This means it can differentiate between instances where a change to a source file causes a change in the behaviour of the program and instances where it does not.   
%@nonl
%@-node:paran.20140731173741.2006:<<tool desc>>
%@nl

\section{What the tool does}
%@<<What the tool does>>
%@+node:paran.20140605081907.1971:<<What the tool does>>
%@+at
% answer what it does
%@-at
%@@c

%@<<detecting moves>>
%@+node:paran.20140606104644.2007:<<detecting moves>>
By checking to see if an insert at one point matches a delete at another point it is possible to detect to see if the code block has moved. In order to determine if the move is one that has no impact the matches are only counted if a match can be found within the same container.  If methods have been shifted within a class they will be evaluated to determine if there is a suitable match.  If a method is shifted from one class to an inner class however it no longer exists in the same container.  In this circumstance it is less likely that the changes have produced source code that behaves in the same manner.
%@nonl
%@-node:paran.20140606104644.2007:<<detecting moves>>
%@nl

%@<<detecting renames>>
%@+node:paran.20140606104644.2009:<<detecting renames>>
To a limited extent the refactor categories tool can also deal with copies and renaming.
%@nonl
%@-node:paran.20140606104644.2009:<<detecting renames>>
%@nl

%@<<detecting comments>>
%@+node:paran.20140606104644.2011:<<detecting comments>>
The refactor categories tool first does a cursory examination of the text differences between two files. It then examines both the differences in executable Java code and the differences between comments and white-space. 
%@-node:paran.20140606104644.2011:<<detecting comments>>
%@nl

%@<<detecting whitespace>>
%@+node:paran.20140606104644.2012:<<detecting whitespace>>

The refactor categories tool first does a cursory examination of the text differences between two files. It then examines both the differences in executable Java code and the differences in white-space.
%@nonl
%@-node:paran.20140606104644.2012:<<detecting whitespace>>
%@nl

%@-node:paran.20140605081907.1971:<<What the tool does>>
%@nl

\section{Design decisions}
%@<<design decisons>>
%@+node:paran.20140605081907.1972:<<design decisons>>
%@+at
% answer why it does stuff
%@-at
%@@c

%@+at 
%@nonl
% answer how does stuff
%@-at
%@@c

%@+at
% insert diagram of how it finds the ASTs that are within the change set
% 
% they are not associated with the AST changes because a comment could be at
% the end of a line and thus associated with the change before.  A multi-line
% comment is normally about the line that follows
%@-at
%@@c  

%@<<compares changes>>
%@+node:paran.20140801074838.2011:<<compares changes>>
There are a number of design differences between JDime and the refactor categories tool.  Instead of doing a text comparison first and only proceeding to analyse the program using an AST if there are conflicts the categorisation tool examines all files that have a difference in them.  Although this takes longer and is more memory intensive there are some advantages to this. The main advantage is related to the concept of keeping branches as consistent as possible whenever there is a change. An example of this advantage is if a merge was done using an ordinary text comparison and there is a non functional change to only one revision. Examples of a non functional change could include reordering methods or inserting a comment.  As the changes were only done to one of the revisions there is no conflict and JDime only does a text based merge.  During this text based merge, in addition to any of the changes to functionality that we want, we get the non functional changes that change the source code without changing the programs' behaviour. By examining all changes irrespective of if the text has conflicts means that the refactor categories tool can determine if it is a change that would not affect the behaviour of a program.
%@nonl
%@-node:paran.20140801074838.2011:<<compares changes>>
%@nl

%@<<drilldown>>
%@+node:paran.20140606104644.2019:<<drilldown>>
As there is a cost overhead with testing all the changes rather than just the conflicting ones the categorisation tool needs to be efficient in how it tests changes.  Assuming that changes occur in select areas within the file there are portions of the file that have not been changed.  We have developed a method that spends a smaller amount time in  within the portions that have already been identified as not containing changes.  Like JDime we initially do a text based merge.  The text based merge we use however uses the histogram merge in JGit.  This allows us to use information from the text based merge when we analyse the AST tree.  The information used is the ranges of line numbers and operations identified by the histogram merge. The change set has been taken from the original JGit based diff contains the start and end of the change in both files and what type of change it is (insert delete or modify).  By reusing these ranges of line numbers it is possible to figure out which AST items these changes affect. This is done by loading the file into the JastAddJ parser to get an AST tree. Line numbers for each item in the tree are then compared to line numbers from the change set. The line numbers are matched to the position information stored in each AST node using the following method.

The root of the AST is identified as the AST node we need to start at. 
We only begin any analysis, if the AST node resides completely within a block of text changes.
If there are any separate blocks of changes that occur between the start position of the AST node and the end position of the AST node then we recursively examine the AST nodes children.

%@+at
% The refactor categories tool first works out which text has changed using 
% the same method as JGit.
% This initial examination returns the differences based on a line by line 
% basis rather than using a smaller granularity.
% This means that the set of changes found could still contain code that is 
% comparatively the same.
% The set of changes found in using the JGit histogram comparison are then 
% evaluated.
% The reason for this is that some items of text could be in a differing order 
% but still be a valid Java program
% 
% 
% In order to resolve some limitations with JDime and the text only merge in 
% GIT information about which line numbers are retained after the first text 
% merge.  In JDime these are ignored and the AST is relied upon to hold all 
% the information.
%@-at
%@@c


%@+at
% after finished drill down we have a record of the same changes as JGit
% except now we also have the ASTs
%@-at
%@@c 
%@nonl
%@-node:paran.20140606104644.2019:<<drilldown>>
%@nl

%@<<resolving gaps>>
%@+node:paran.20140801202652.2011:<<resolving gaps>>
In some instances there is no position information stored in the JastAddJ AST nodes.  This could be because they are generated by the parser to reflect parts of the Java language that are inferred rather than directly mentioned in the code.  An example of this would be the use of super in the constructor.  Even if it is not written in the code for every constructor has a super. Likewise all methods mentioned in an interface have a public type even if is not in the code.

To get around this problem we have needed to discover the end position of the previous AST Node to determine the position the inferred AST node should occupy.  This means that the inferred AST node is in the right position but is not represented by a block of text in the source code. 
%@nonl
%@-node:paran.20140801202652.2011:<<resolving gaps>>
%@nl

%@+at 
% need to add something about the choice of java and jastaddj
%@-at
%@@c

%@<<comments and white space>>
%@+node:paran.20140606104644.2018:<<comments and white space>>
Comment and white-space are also examined separately as they also could give some indication of where code has been moved from or to.
Before being checked to find matches unnecessary white-space is identified and recorded.
Any text that remains is examined to determine if its is a comment. 

Because of the way we are using the position in the code to identify AST nodes there are circumstances when parts of the Java programming language are identified as being surplus text. These have already been identified and represented as an AST Node. By identifying comments we can eliminate any of the items falsely recorded as comments.

%@+at 
% Comments and white-space cannot be shown in the AST tree so they need to be
% dealt with separately
%@-at
%@@c
%@nonl
%@-node:paran.20140606104644.2018:<<comments and white space>>
%@nl

%@<<matcher>>
%@+node:paran.20140606104644.2016:<<matcher>>
%@+at
% comparing AST nodes
% the matcher and how using a score works
% finding the best match
% 
% 
% explain how we limit matching just to the parent of the thing being matched
%@-at
%@@c

Rather than comparing everything with each other to determine matches it is more efficient to match just the items that are under the same AST structure.  This means that it is more likely that we get a match that is going to be relevant and valid.  An example of this is matching methods. If the methods are under the same container (a class) they may be legally swapped without causing issues.  If the method has been moved to an inner class from an outer one however it becomes more complicated and we cannot guarantee that the code is equivalent.  
%@nonl
%@-node:paran.20140606104644.2016:<<matcher>>
%@nl

%@+at
% why does it do it for the whole repository
%@-at
%@@c

%@+at
% 
% note: we might want to use some literate programming here11
%@-at
%@@c
%@nonl
%@-node:paran.20140605081907.1972:<<design decisons>>
%@nl

\section{Limitations of the tool}
%@<<limitations>>
%@+node:paran.20140605081907.1993:<<limitations>>
The refactor categories tool focuses only on areas where there has been a change in the source code. 
It is harder to investigate any change that has causes side effects in unchanged code.  Fortunately it is not often that this type of side effect will be purposely placed in the code as it reflects bad design decisions.  This may however be an issue with bugs, which are unintentionally placed in the code.  
This also means that the refactor categories tool will not be able to tell when some code has been copied but the original remains unchanged. Instead it will assume that it is a completely new insertion of code.
%@-node:paran.20140605081907.1993:<<limitations>>
%@nl
%@-node:paran.20140514103950.1918:@shadow theTool.tex
%@-leo
