
\chapter{Refactor categories tool}

The catagorisation tool examines the differences differerences between files and arranges them into a greater variety of categories than used by version control systems or merge and diff tools.  In addition to being able to detect instances of delete, insert and modify the categoristaion tool can also detect instances where the code has been relocated and to some extent renamed.  It also can differentiate between changes to comments, whitespace and Java code.

\section{What the tool does}
% answer what it does
The refactor categories tool enhances JGit by adding the concept of source code moving to JGits representation of changes.
Currently JGit labels any of the differences it encounters as an insert, a delete, or a modification.  By checking to see if an insert at one point matches a delete at another point it is possible to detect to see if the code block has moved.
To a limited extent the refactor categories tool can also deal with copies and renaming.

By checking to see if an insert at one point matches a delete at another point it is possible to detect to see if the code block has moved. In order to determine if the move is one that has no impact the matches are only counted if a match can be found within the same container.  If methods have been shifted within a class they will be evaluated to determine if there is a suitable match.  If a method is shifted from one class to an inner class however it no longer exists in the same container.  In this circumstance it is less likely that the changes have produced source code that behaves in the same manner.

To a limited extent the refactor categories tool can also deal with copies and renaming.

The refactor categories tool first does a cursory examination of the text differences between two files. It then examines both the differences in executable Java code and the differences between comments and white-space. 


The refactor categories tool first does a cursory examination of the text differences between two files. It then examines both the differences in executable Java code and the differences in white-space.


\section{How the tool works}
% answer how does stuff

The refactoring difference tool first works out which text has changed using the same method as JGit.
This initial examination returns the differences based on a line by line basis rather than using a smaller granularity.
This means that the set of changes found could still contain code that is comparatively the same.
The set of changes found in using the JGit histogram comparison are then evaluated.
The reason for this is that some items of text could be in a differing order but still be a valid Java program


In order to resolve some limitations with JDime and the text only merge in GIT information about which line numbers are retained after the first text merge.  In JDime these are ignored and the AST is relied upon to hold all the information.  The change set has been taken from the original GIT based diff contains the start and end of the change in both files and what type of change it is (insert delete or modify).  By reusing these line numbers it is possible to figure out which AST items these changes affect. This is done loading the file into the JastAddJ parser to get an AST tree. The line numbers for each item in the tree are then comparing line numbers from the change.

There is a problem with using JastAddJ to do this. Some ASTs do not contain an equivalent position in the code.  This could be because they are generated by the parser to reflect parts of the Java languge that are infered rather than directly mentioned in the code.  An example of this would be the use of super in the constructor.  Even if it is not written in the code for every constructor has a super. Likewise all methods mentioned in a interface have a public type even if is not in the code.

To get aound this problem we have needed to record the previous valid position for a Java command as both the start and end of the AST that had no line numbers assigned to it.  This means that the infered AST is in the right position but is not represented by a block of source code.

% after finished drill down we have a record of the same changes as JGit
% except now we also have the ASTs

% explain how we limit matching just to the parent of the thing being matched

Rather than comparing everything with each other to determine matchs it is more efficient to match just the items that are under the same AST structure.  This means that it is more likely that we get a match that is going to be relivant and valid.  An example of this is matching methods. If the methods are under the same container (a class) they may be legally swapped without causing issues.  If the method has been moved to an inner class from an outer one however it becomes more complicated and we cannot guarantee that the code is equivalent.     

Comment and white-space are also examined separately as they also could give some indication of where code has been moved from or to.
Before being checked to find matches unnecessary white-space is identified and recorded.
Any text that remains is examined to determine if its is a comment.  Because of the way im using the position in the code to identify ASTs there are circumstances when parts of the java programming language are identified as being surplus text. These have already been identified and represented as an AST Node. By identifying comments we can eliminate any of the items falsely recorded as comments.

% Comments and white-space cannot be shown in the AST tree so they need to be
% dealt with separately


% insert diagram of how it finds the ASTs that are within the change set
% 
% they are not associated with the AST changes because a comment could be at
% the end of a line and thus associated with the change before.  A multi-line
% comment is normally about the line that follows

\section{Design decisions}
% answer why it does stuff

There are a number of design differences between JDime and the categorisation tool.  Instead of doing a text comparison first and only proceeding to analyse the program using an AST if there are conflicts the categorisation tool examines all files that have a difference in them.  Although this takes longer and is more memory intensive there are some advantages to this. The main advantage is related to the concept of keeping branches as consistant as possible whenever there is a change. An example of this advatantage is if a merge was done using an ordinary text comparison and therse is a non functional change to only one revision. Examples of a non functional change could include reordering methods or inserting a comment.  As the changes were only done to one of the revisions there is no conflict and JDime only does a text based merge.  During this text based merge, in addition to any of the changes to fuctionality that we want, we get the non functional changes that change the source code without changing the programs behaviour. By examining all changes irrespective of if the text has conflicts means that the categoristation tool can determine if change that would not affect the behavior of a program is occuring.


As there is a cost overhead with testing all the changes rather than just the conflicting ones the categorisation tool needs to be efficient in how it tests changes.  Assuming that changes occur in select areas within the file there are portions of the file that have not been changed.  We have developed a method that spends a smaller amount time in  within the portions that have already been idenfied as not contitaining changes.  Like JDime we initially do a text based merge.  The text based merge we use however uses the histogram merge in JGit.  This allows us to use information from the text based merge when we analyse the AST tree.  The information used is the ranges of line numbers and operations identified by the histogarm merge.  The line numbers are matched to the position information stored in each AST node using the following method.

The root of the AST is identified as the AST node we need to start at. 
We only begin any analysis if the AST node resides completely within a block of text changes.
If there are any seperate blocks of changes that occur between the start position of the AST node and the end position of the AST node then we recursively examine the AST nodes children.

% need to add something about the choice of java and jastaddj

comments
white-space

comparing ASTs
the matcher and how using a score works
finding the best match

% why does it do it for the whole repository

% 
% note: we might want to use some literate programming here11

\section{Limitations of the tool}
The refactor categories tool drills down only on the changes it is harder to investigate any change that has causes side effects in unchanged code.  It is not often that a side effect will be purposely placed in the code as it reflects bad design decisions.  This may however be an issue with bugs.  This also means that the refactor categories tool will not be able to tell when some code is copied but the original remains unchanged. Instead it will assume that it is a completely new insertion of code.
