%@+leo-ver=4-thin
%@+node:hasletpara.20130905084546.1629:@shadow ./fmpp/Tex/Proposal.tex
%@@language latex
\documentclass[12pt]{CRPITStyle} 
%\usepackage{epsfig} % Packages to use if you wish
%\usepackage{lscape} % 
\usepackage[authoryear]{natbib}
\usepackage{graphicx}
\renewcommand{\cite}{\citep}
\pagestyle{empty}
\thispagestyle{empty}
\hyphenation{roddick}
\onecolumn
\begin{document}

%@<<title>>
%@+node:hasletpara.20130905084546.1630:<<title>>
\title{Thesis Proposal}
\author{Paran D Haslett (300274241)}
\affiliation{School of Engineering and Computer Science\\
Room C168C\\
Cotton Building\\
Victoria University of Wellington\\
Gate 6, Kelburn Parade\\
Wellington, \\
Email :~{\tt Paran.Haslett@ecs.vuw.ac.nz}}
%@-node:hasletpara.20130905084546.1630:<<title>>
%@nl
\maketitle

%@<<abstract>>
%@+node:hasletpara.20130905084546.1631:<<abstract>>
\begin{abstract}
When collaborating on a project there are times where having your own personal notes, comments about a file are necessary for your own personal understanding.  This could at times also involve how the structure of the program is presented or the variable and method names that you use. This is especially true if there is a piece of functionality that you wish to work on that differs from what everyone else is working on.  In these cases you may need to refactor the code to best suit your changes before you apply them. The ability to have a separate view which although functionally equivalent to other views can present the code in a different form in these situation would be valuable.  It enables the programmer to refactor or change the code with minimal impact on others.
\end{abstract}
\vspace{.1in}

\noindent {\em Keywords :  Personal annotations,  Collaboration, Multiple views, Semantic Merge, Syntactic Merge} 
%@-node:hasletpara.20130905084546.1631:<<abstract>>
%@nl

%@<<body>>
%@+node:hasletpara.20130905084546.1632:<<body>>
%@+others
%@+node:hasletpara.20130905084546.1650:Introduction
\section{Introduction}
There are some issues that arise in Software Development when code diverges from a point.  This divergence could be caused for a number of reasons including adding new functionality, refactoring, or code being reused.  In some cases when code diverges it could be helpful to reatinrelations  Each person has different ways in which they best understand, develop and refactor code.  Sometimes there are even different ways in which an individual will approach a different task or challenge.  We will now examine those issues in more detail
%@+others
%@+node:hasletpara.20130905084546.1662:The problem
 %@ @+others
 %@+node:hasletpara.20130905084546.1667:refactoring
 \subsection{Refactoring}
 A common concern with coding is the need to periodically refactor the code.  According to Fowler et al. the main time he refactors is when he is adding new functionality \cite{Fowler1999}. Similarly according to Kerievsky some of the motivations for refactoring include adding more code and understanding existing code \cite{Kerievsky2004} .  As adding more functionality is one of the motivations let us consider what happens in a multi-developer environment. Two developers could have different view on what is considered an appropriate refactoring. This is especially true if they need to add different functionality from each other.  


 A simple example is if the code is initially as follows:
 \begin{verbatim}
 import java.util.Scanner;

 public class TempConv {
 	public static void main(String[] args) {
 		Scanner keyboard = new Scanner(System.in);
 		System.out.println("Enter the temperature in Celsius");
 		int celsius = keyboard.nextInt();
 		System.out.println("Degrees Fahrenheit is approx " + (celsius * 2 + 30) );
 		keyboard.close();
 	}
 }
 \end{verbatim}

 Refactoring this code depends on what functionality you need to add. One developer may recognize that conversion from celsius may be used several times throughout the code and so extract the calculations as a separate method as follows:

 \begin{verbatim}
 import java.util.Scanner;

 public class TempConv {
 	public static void main(String[] args) {
 		new TempConv();
 	}
 	
 	public TempConv() {
 		Scanner keyboard = new Scanner(System.in);
 		System.out.println("Enter the temperature in Celsius");
 		int celsius = keyboard.nextInt();
 		System.out.println("Degrees Fahrenheit is approx " + celsiusToFahrenheit(celsius) );
 		keyboard.close();
 	}
 	
 	public int celsiusToFahrenheit(int celsius){
 		return celsius *2 + 30;	
 	}
 }
 \end{verbatim}

 This change in spite of producing the same output as the first provides a number of advantages.  Firstly if other programs need to convert from Celsius to Fahrenheit the new method can easily be accessed. Secondly since the calculation is a crude estimation it becomes a lot clearer where the code needs to be changed for a much better formula.  Being able to add a method that clearly indicates that the calculation is from Celsius to Fahrenheit helps with the readability of the code. There are also disadvantages with doing this refactoring however.  If we do not care about conversion between Celsius and Fahrenheit the refactoring simply adds to the amount of code we need to wade through before understanding what the code does.  If the new functionality was to add the ability to figure out Fahrenheit to Celsius the refactoring may have been different.  If temperature conversion was not the only calculation it could be vastly different again. As the value of a particular refactoring appears to depend on what is trying to be achieved it is very hard to claim that one refactoring is better than another.


 %@-node:hasletpara.20130905084546.1667:refactoring
 %@+node:hasletpara.20130905084546.1664:Differences in understanding code
 \subsection{Differences in how code is understood}
 Another reason that \cite{Kerievsky2004}claims for refactoring code is to better understand it. The very act of going through the source code and reprocessing it in a clearer form can help with the understanding of it. This would suggest that either developers tend to leave code in a difficult to understand state or that different developers understand things differently.
  \cite{Kerievsky2004} also relates a tale about how the lack of knowledge of patterns making a particular refactoring look a lot more complex.  The different perspectives meant that the programmer he refers to as John having a differing opinion that the refactored code was not an improvement. This shows that it is not just different functionality that influences the need to refactor but sometime the knowledge and experience of the developers themselves. It is often the case that two developers could have different views about what is an appropriate refactoring. This could be because each person brings different skills, notices different issues and has a preferred way of visualizing a problem and solution.

 %@-node:hasletpara.20130905084546.1664:Differences in understanding code
 %@+node:hasletpara.20131104103532.1627:Multiple developers
 \subsection{Working on large projects with multiple developers}
 \cite{Perry2001} Claimed that there are not adequate tools to use with projects with multiple developers. Whilst a lot of differences between two different versions of source code can be already merged by source control refactoring often involves larger structural changes. According to \cite{freese2007operation}these larger changes can lead to merge problems if a traditional text difference approach is used. This has lead to the development of smarter merge technology being used to compare code. The simplest of these being hunting for regular expressions so that white-space is not a factor during merging. Some more complicated examples of this are presented by \cite{Leßenich2012} and \cite{Apel2011} who both identify in addition to text based merging both structured and semi-structured approaches to merging. Although \cite{Leßenich2012} briefly talks about using GIT with a semi structured merge they have named \"JDime\" there are some interesting features of distributed version control system that have not been explored.

 \begin{center}
 \includegraphics[scale=0.5]{git-diag}
 \end{center}

 In the above diagram we have situation where two branches have diverged in Git and we would like to merge only the changes that would have a functional difference.  Although there has been some success in doing this the history of Git has not been used.  The head of branch one is compared with the head of branch two. What this means is that information about concerning each stepped change could be lost. 

   
 %@-node:hasletpara.20131104103532.1627:Multiple developers
 %@+node:hasletpara.20131031084746.1626:big ball of mud
 \subsection{Big Ball of Mud}
 Some of this could be that people have a different view of the code.
 According to \cite{Foote1997} throwaway code is a major cause for the most often coded Big Ball of Mud pattern.  Some of this could be made worse by source control merges not being able to identify the throwaway code.  This means that some quick and dirty fixes make their way from branches into the main stream.
 %@-node:hasletpara.20131031084746.1626:big ball of mud
 %@+node:hasletpara.20131105141303.1629:reuse
 \section{Reuse}
 Another reason you may want to diverge from a point is when the code is being reused.  Often it needs to be refactored to fit in with the new code.  Once it has been refactored it is then difficult to apply a wanted change from the original code.
 %@-node:hasletpara.20131105141303.1629:reuse
 %@+node:hasletpara.20131112095537.1644:
 %@-node:hasletpara.20131112095537.1644:
 %@-others

 
 
 
 
 

 
%@-node:hasletpara.20130905084546.1662:The problem
%@-others


%@-node:hasletpara.20130905084546.1650:Introduction
%@+node:hasletpara.20130905084546.1651:Background
\section{Background}
There are a number of methodologies, designs and practices that are related.  These have been used in the past to come to a common understanding or a different abstraction of the source code.
%@+others
%@+node:hasletpara.20130905084546.1653:Related Work
\subsection{Related Work}
One approach that has been tried in an effort to manage different points of view is by ensuring that there is an agreed upon common understanding.  The weakness with this is that there is an excessive amount of adjustment time for each person that needs to interact with the code. The converse approach allows scope for different facets of source code to be displayed.  The weakness still inherent in this is that most of these facets attack the issue using a graphical fount end without considering what changes could be mad at the source code level.  They also in an effort to reduce the complexity of displaying the code on the screen strip away some of the valuable meta-data that could provide context.     
%@+others
%@+node:hasletpara.20130910094414.1578:Archetecture
\subsubsection{Architecture and design}
One of the ways of arriving at a consensus about source code is to have a predefined architecture.  According to \cite{Tang2009} the problem with this is that is is often hard to determine an appropriate design before something is implemented. It also requires the intervention of an architect and assumes that there is if not one right way to represent code that should be chosen and agreed upon.  \cite{Taylor2007} claims that there will always be the need for design and this view for the most part is correct.  What this view overlooks however is that a different perspective or different design may be better suited to a different task. \cite{Taylor2007} spends quite some time discussing different perspectives and paradigms but does not develop this further into an understanding that there could be equivalently well designed artifacts for the same purpose that differ.
%@-node:hasletpara.20130910094414.1578:Archetecture
%@+node:hasletpara.20130910094414.1579:Design patterns
\subsubsection{Design patterns}
Design patterns are another way which has been used to identify the correct code for a particular issue. Due to the dynamic nature of source code however it may be useful to consider different design patterns for differing tasks.
%@-node:hasletpara.20130910094414.1579:Design patterns
%@+node:hasletpara.20130910094414.1580:Well Documented Code
%@-node:hasletpara.20130910094414.1580:Well Documented Code
%@+node:hasletpara.20130910094414.1581:Model Driven Development
%@-node:hasletpara.20130910094414.1581:Model Driven Development
%@+node:hasletpara.20130910094414.1582:version control
\subsection{version control} 
%@-node:hasletpara.20130910094414.1582:version control
%@+node:hasletpara.20130910094414.1583:Mviews
\subsubsection{MViews}
Mviews is a way to focus on a small subsection of code in a more graphical way.  It is of interest as provides a previously unseen abstraction of the code 
%@-node:hasletpara.20130910094414.1583:Mviews
%@-others
%@-node:hasletpara.20130905084546.1653:Related Work
%@-others



%@-node:hasletpara.20130905084546.1651:Background
%@+node:hasletpara.20130905084546.1652:Proposed Approach
\section{Proposed Approach}
  The proposed approach is to look at the code associated with Git and JDime and figure out how we can relate each step in git to  a merge.
  Using JDime and Git as a starting point see anything can be gained by using the additional steps rather than just merging the top items in a single merge .  This should not be as computationally expensive as it sounds if the Semi-structured approach set forward by Olaf means that this is only necessary for  conflicting items.  In addition to this if a record is kept of conflicting items that are marked as being functionally equivalent they do not need to be included in merge.  The simplest of these would be comments that have been marked as being functionally irrelevant.  If there is a conflict with the comment in one branch with a line of code in another branch having the comment marked as being superfluous gives the indication that the line of code is the preferred rendition of the final result.  Another reason to mark something as functionally irrelevant might be if there is throwaway code that you do not want propagated over your whole version control system.  Instead of just writing a TODO to say this is not the best way to implement the code placing some marker in the file so that whoever copies the code now become responsible for manually coping across the unwanted hack or rewriting it properly is a good feature. The way of marking code as being superfluous or 
  
  
  
   
  
 \cite{Freese2006a} also proposed a prototype eclipse plug-in for making the version control aware about refactoring code.
 
%@+at
% The solution to these issues that I am proposing goes a little further in 
% separating
%@-at
%@@c
%@+at
% initially as a diff tool for GIT
% initially dealing with code comments that may not need to be transfered
%@-at
%@@c
%@-node:hasletpara.20130905084546.1652:Proposed Approach
%@-others


%@-node:hasletpara.20130905084546.1632:<<body>>
%@nl

%@<<bibliography>>
%@+node:hasletpara.20130905084546.1649:<<bibliography>>
\bibliography{Proposal}
\bibliographystyle{agsm}
%@-node:hasletpara.20130905084546.1649:<<bibliography>>
%@nl

\end{document}

%@-node:hasletpara.20130905084546.1629:@shadow ./fmpp/Tex/Proposal.tex
%@-leo
