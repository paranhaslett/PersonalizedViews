<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="paranhaslett.20130826181255.2958" a="E"><vh>Thesis</vh>
<v t="paranhaslett.20130826181255.2959" a="E"><vh>Documents</vh>
<v t="hasletpara.20131121100256.1778" a="E"><vh>format for thesis</vh>
<v t="hasletpara.20131121100256.1789"><vh>&lt;&lt;Front part&gt;&gt;</vh>
<v t="hasletpara.20131121100256.1786"><vh>&lt;&lt;Title Page&gt;&gt;</vh>
<v t="hasletpara.20131121100256.1779"><vh>&lt;&lt;header&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1780"><vh>&lt;&lt;title&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1781"><vh>&lt;&lt;author&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1782"><vh>&lt;&lt;Supervisors&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1783"><vh>&lt;&lt;Date&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1784"><vh>&lt;&lt;towards&gt;&gt;</vh></v>
</v>
<v t="hasletpara.20131121100256.1785"><vh>&lt;&lt;Abstract&gt;&gt;</vh></v>
</v>
<v t="hasletpara.20131121100256.1788"><vh>&lt;&lt;Introduction&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1790"><vh>&lt;&lt;Background&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1791"><vh>&lt;&lt;How it was implemented&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1792"><vh>&lt;&lt;How UI was implemented&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1793"><vh>&lt;&lt;Evaluation&gt;&gt;</vh></v>
<v t="hasletpara.20131121100256.1794" a="E"><vh>&lt;&lt;Conclusion&gt;&gt;</vh>
<v t="hasletpara.20131121100256.1795"><vh>&lt;&lt;Recommendations&gt;&gt;</vh></v>
</v>
</v>
<v t="paranhaslett.20130826181255.2960" a="E"
expanded="paranhaslett.20130826181255.2963,paranhaslett.20130826181255.2964,"><vh>@shadow ./fmpp/Tex/Thesis.tex</vh></v>
<v t="hasletpara.20130905084546.1629" a="E"
expanded="hasletpara.20130905084546.1632,hasletpara.20130905084546.1650,hasletpara.20130905084546.1662,hasletpara.20130905084546.1667,hasletpara.20130905084546.1653,hasletpara.20130905084546.1652,"><vh>@shadow ./fmpp/Tex/Proposal.tex</vh></v>
</v>
<v t="paranhaslett.20130826181255.3074" a="E"><vh>Notes</vh>
<v t="paranhaslett.20130826181255.3103"><vh>Expirements</vh>
<v t="paranhaslett.20130826181255.3104"><vh>Download Mviews SNART</vh></v>
<v t="paranhaslett.20130826181255.3105"><vh>Set it up with eclipse plugins</vh></v>
<v t="paranhaslett.20130826181255.3106"><vh>download TA-RE</vh></v>
<v t="paranhaslett.20130826181255.3107"><vh>Set up an expirment with GIT</vh>
<v t="paranhaslett.20130826181255.3115"><vh>Code equivlency</vh></v>
</v>
</v>
<v t="paranhaslett.20130826181255.3109"><vh>Ideas</vh>
<v t="paranhaslett.20130826181255.3110"><vh>Preserving a structure during change</vh>
<v t="paranhaslett.20130826181255.3111"><vh>1) by reatining a before and after of an entry</vh></v>
<v t="paranhaslett.20130826181255.3112"><vh>2) by placing an id beside an entry</vh></v>
<v t="paranhaslett.20130826181255.3113"><vh>3) by taking note of Java syntax and treating it as the units of exchange</vh></v>
<v t="paranhaslett.20130826181255.3114"><vh>4) depends on the structure preserved</vh></v>
</v>
<v t="paranhaslett.20130826181255.3115"></v>
<v t="paranhaslett.20130826181255.3116"><vh>Ordering</vh></v>
<v t="paranhaslett.20130826181255.3117"><vh>2 views relationship</vh>
<v t="paranhaslett.20130826181255.3118"><vh>need a way to display differing views of the same base data</vh></v>
</v>
<v t="paranhaslett.20130826181255.3119"><vh>Differences in function ordering</vh></v>
<v t="paranhaslett.20130826181255.3111"></v>
<v t="paranhaslett.20130826181255.3112"></v>
<v t="paranhaslett.20130826181255.3113"></v>
<v t="paranhaslett.20130826181255.3114"></v>
<v t="paranhaslett.20130826181255.3118"></v>
</v>
<v t="paranhaslett.20130826181255.3147"><vh>Programming</vh>
<v t="paranhaslett.20130826181255.3148"><vh>xml</vh>
<v t="paranhaslett.20130826181255.3149"><vh>xml of the model</vh></v>
<v t="paranhaslett.20130826181255.3150"><vh>xml containing the file (which may be the same as above</vh></v>
</v>
</v>
<v t="paranhaslett.20130827232850.1595"><vh>To do</vh>
<v t="paranhaslett.20131022191134.1801"><vh>Plan</vh>
<v t="paranhaslett.20131022191134.1802"><vh>Tonight</vh></v>
<v t="paranhaslett.20131022191134.1803"><vh>Tommorrow</vh></v>
</v>
</v>
<v t="paranhaslett.20130826181255.3148"></v>
<v t="paranhaslett.20130826181255.3149"></v>
<v t="paranhaslett.20130826181255.3150"></v>
<v t="paranhaslett.20131022191134.1801"></v>
</v>
<v t="paranhaslett.20130826181255.3057"><vh>Structures</vh>
<v t="paranhaslett.20130826181255.3058"><vh>Tab</vh></v>
<v t="paranhaslett.20130826181255.3059"><vh>Menu</vh></v>
<v t="paranhaslett.20130826181255.3060"><vh>Tag</vh></v>
<v t="paranhaslett.20130826181255.3061"><vh>Node</vh></v>
</v>
<v t="paranhaslett.20130826181255.3062"><vh>Web Pages</vh>
<v t="hasletpara.20131121100256.1776"><vh>Data</vh>
<v t="hasletpara.20131121100256.1777"><vh>@shadow ./fmpp/data/tabbedPages.csv</vh></v>
</v>
<v t="hasletpara.20130905134207.1647"><vh>@shadow ./create.sh</vh></v>
<v t="hasletpara.20131121100256.1774"><vh>@shadow ./config.fmpp</vh></v>
<v t="paranhaslett.20130826181255.3063"><vh>Personal Uni Home</vh>
<v t="hasletpara.20130905131851.1629"><vh>@shadow ./config.fmpp</vh></v>
<v t="hasletpara.20130905134207.1629"><vh>@shadow ./fmpp/public_html/generic.html</vh></v>
</v>
<v t="paranhaslett.20130826181255.3068"><vh>Ema Wiki</vh>
<v t="paranhaslett.20130826181255.3069"><vh>@shadow ../../Dropbox/PersonalWiki/Study.txt</vh></v>
<v t="paranhaslett.20130826181255.3070" a="E"
expanded="paranhaslett.20130826181255.2964,"><vh>@shadow ../../Dropbox/PersonalWiki/Thesis.txt</vh></v>
<v t="paranhaslett.20130826181255.3073"
expanded="paranhaslett.20130826181255.3074,"><vh>@shadow ../../Dropbox/PersonalWiki/Study_Notes.txt</vh></v>
<v t="paranhaslett.20130826181255.3151" a="E"><vh>@shadow ../../Dropbox/PersonalWiki/Structures.txt</vh></v>
</v>
<v t="paranhaslett.20130826181255.3157" a="E"><vh>Grad Wiki</vh>
<v t="paranhaslett.20130826181255.3158" a="E"><vh>@shadow ./fmpp/GradWiki/Wiki.txt</vh></v>
</v>
</v>
<v t="hasletpara.20131127121911.1852"><vh>ScratchPad</vh>
<v t="hasletpara.20131122093500.1836"><vh>testing on checkins</vh></v>
<v t="hasletpara.20131122093500.1835"><vh>Variable names</vh></v>
<v t="hasletpara.20131122093500.1834"><vh>planned method of test</vh></v>
<v t="hasletpara.20131122093500.1833"><vh>merge git and Jdime</vh></v>
<v t="hasletpara.20131122093500.1832"><vh>leverage JDime</vh></v>
<v t="hasletpara.20131122093500.1831"><vh>seperate branch</vh></v>
<v t="hasletpara.20131122093500.1830"><vh>annotations</vh></v>
<v t="hasletpara.20131115102112.1759"><vh>Proposed Approach</vh></v>
<v t="hasletpara.20130905084546.1651"><vh>Background</vh></v>
<v t="hasletpara.20130909092051.1567"><vh>The Solution</vh></v>
<v t="hasletpara.20131112095537.1645"><vh>old refactoring stuff</vh></v>
<v t="hasletpara.20131112095537.1646"><vh>old differences in understanding code</vh></v>
<v t="hasletpara.20130905084546.1654"><vh>Other Background</vh>
<v t="hasletpara.20130909092051.1590"><vh>Keeping on the same page</vh></v>
<v t="hasletpara.20130909092051.1568"><vh>Previous solutions</vh></v>
<v t="hasletpara.20130905084546.1665"><vh>Other Tools</vh></v>
</v>
<v t="hasletpara.20130909092051.1589"><vh>IP</vh></v>
<v t="hasletpara.20130905084546.1663"><vh>Differeces in creating code</vh></v>
<v t="paranhaslett.20130826181255.3120"><vh>Papers being read</vh>
<v t="paranhaslett.20130826181255.3121"><vh>Code Source Mining</vh>
<v t="hasletpara.20130902092846.1747"><vh>Article: FRUIt</vh></v>
<v t="paranhaslett.20130826181255.3122"><vh>Article: Mining Software Repositories with iSPAROL and a Software Evolution Ontology</vh></v>
<v t="paranhaslett.20130826181255.3123"><vh>Article: TARE An Exchange Language for Mining Software Repositories</vh></v>
</v>
<v t="paranhaslett.20130826181255.3124"><vh>CSCW</vh>
<v t="paranhaslett.20130826181255.3125"><vh>Article: CSCW and Education</vh></v>
<v t="paranhaslett.20130826181255.3126"><vh>Article: Why CSCW needs Science Policy</vh></v>
</v>
<v t="paranhaslett.20130826181255.3127"><vh>Modeling and Code Viewing</vh>
<v t="paranhaslett.20130826181255.3128"><vh>Article: An EXtensible Framework for providing Dynamic Data Structure Visualisations</vh></v>
<v t="paranhaslett.20130826181255.3129"><vh>Article: Constructing  Multi-View Editing Eviroments Using MViews</vh></v>
<v t="paranhaslett.20130826181255.3130"><vh>Article: FRUIt</vh></v>
<v t="paranhaslett.20130826181255.3131"><vh>Article: Software Dev enviroments on the web</vh></v>
<v t="paranhaslett.20130826181255.3132"><vh>Article:Shrimp</vh></v>
<v t="paranhaslett.20130826181255.3133"><vh>Article: Towards a Prctical Visual OO Programming environment</vh></v>
</v>
<v t="hasletpara.20130829091513.1651"><vh>Program Slicing</vh></v>
<v t="hasletpara.20130828093505.1608"><vh>Syntactically aware comparison tools</vh></v>
<v t="paranhaslett.20130826181255.3134"><vh>Templates and Macros</vh>
<v t="paranhaslett.20130826181255.3135"><vh>Article: Behaviorial Similarity Matching using Concrete Source Code Templates in Logic Queries</vh></v>
<v t="paranhaslett.20130826181255.3136"><vh>Article: Code Templete Inference Using Langugauge Models</vh></v>
<v t="paranhaslett.20130826181255.3137"><vh>Article: Marco: safe, expressive macros for any language</vh></v>
<v t="paranhaslett.20130826181255.3138"><vh>Article: Towards Modular Code Generators Using Symmetric Language-Aware Aspects</vh></v>
</v>
<v t="paranhaslett.20130826181255.3139"><vh>Version Control</vh>
<v t="paranhaslett.20130826181255.3140"><vh>Article: Modern Version Control</vh></v>
<v t="paranhaslett.20130826181255.3141"><vh>Article: Version Control in Crosscutting Framework-Based Development</vh></v>
<v t="hasletpara.20130903084319.1538"><vh>Git</vh></v>
</v>
<v t="paranhaslett.20130826181255.3142"><vh>View Mapping Language</vh>
<v t="paranhaslett.20130826181255.3143"><vh>Article: Mappings the glue in an integrated system</vh></v>
<v t="paranhaslett.20130826181255.3144"><vh>Article:User-centered design of a visual data mapping tool</vh></v>
<v t="paranhaslett.20130826181255.3145"><vh>Article:Domain-specific visual languages for specifying and generating data mapping systems</vh></v>
</v>
<v t="paranhaslett.20130826181255.3146"><vh>Article: Building Usage Contexts During Program Comprehension</vh></v>
</v>
<v t="hasletpara.20131122093500.1829"><vh>how to maintain functional equilvilence</vh></v>
<v t="hasletpara.20131127121911.1853"><vh>newHeadline</vh>
<v t="paranhaslett.20130826181255.3121"></v>
<v t="hasletpara.20130902092846.1747"></v>
<v t="paranhaslett.20130826181255.3122"></v>
<v t="paranhaslett.20130826181255.3123"></v>
<v t="paranhaslett.20130826181255.3124"></v>
<v t="paranhaslett.20130826181255.3127"></v>
<v t="hasletpara.20130829091513.1651"></v>
<v t="hasletpara.20130828093505.1608"></v>
<v t="paranhaslett.20130826181255.3134"></v>
<v t="paranhaslett.20130826181255.3139"></v>
<v t="paranhaslett.20130826181255.3142"></v>
<v t="paranhaslett.20130826181255.3146"></v>
</v>
</v>
</v>
<v t="paranhaslett.20131122184051.1887" a="E"><vh>Recovered Nodes</vh>
<v t="paranhaslett.20131122184051.1888"><vh>Recovered node "Notes from xStudy_Notes.txt</vh>
<v t="paranhaslett.20131122184051.1889"><vh>old:Notes</vh></v>
<v t="paranhaslett.20131122184051.1890"><vh>new:Notes</vh></v>
</v>
</v>
<v t="hasletpara.20131126100506.1825" a="E"><vh>Recovered Nodes</vh>
<v t="hasletpara.20131126100506.1826"><vh>Recovered node "Notes from xStudy_Notes.txt</vh>
<v t="hasletpara.20131126100506.1827"><vh>old:Notes</vh></v>
<v t="hasletpara.20131126100506.1828"><vh>new:Notes</vh></v>
</v>
</v>
<v t="paranhaslett.20131126202038.1911" a="E"><vh>Recovered Nodes</vh>
<v t="paranhaslett.20131126202038.1912"><vh>Recovered node "Notes from xStudy_Notes.txt</vh>
<v t="paranhaslett.20131126202038.1913"><vh>old:Notes</vh></v>
<v t="paranhaslett.20131126202038.1914"><vh>new:Notes</vh></v>
</v>
</v>
<v t="hasletpara.20131127121911.1848" a="E"><vh>Recovered Nodes</vh>
<v t="hasletpara.20131127121911.1849"><vh>Recovered node "Notes from xStudy_Notes.txt</vh>
<v t="hasletpara.20131127121911.1850"><vh>old:Notes</vh></v>
<v t="hasletpara.20131127121911.1851"><vh>new:Notes</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="hasletpara.20130828093505.1608">http://en.wikipedia.org/wiki/Compare%2B%2B

http://discuss.fogcreek.com/joelonsoftware5/default.asp?cmd=show&amp;ixPost=155585&amp;ixReplies=18

http://www.drdobbs.com/tools/worlds-first-language-aware-source-code/240153121

http://stackoverflow.com/questions/77931/do-you-know-of-any-language-aware-diffing-tools

http://www.modelmakertools.com/structured-diff-viewer/index.html
---++++ Syntactically aware comparison tools

Beyond compare seems to use some of these features to compare similar files against each other (not sure how effectivly is does this however)
http://www.scootersoftware.com/moreinfo.php

Altova also has a tool however it is focused on being solely xml aware
http://www.altova.com/diffdog.html

With semantic merge the name says it all. Hopefully they live up to this reputation 
http://www.semanticmerge.com/
This also seems to be about semantic merge
http://rlbisbe.wordpress.com/2013/04/15/semantic-merge-as-the-default-merge-tool-with-git-on-windows/

I am not sure if this is a new one or just is a rehash of semantic merge, SemanticMerge is adverstised on the side bar however some of the converstaion seems to be aimed at the effectiveness of plain text based merging.
http://codicesoftware.blogspot.com/2013/04/put-your-hands-on-programming-language.html


blog on Semantic Conflict by Martin Fowler no less 
http://martinfowler.com/bliki/SemanticConflict.html

Git Diff implemantations (not semantic currently)
https://www.kernel.org/pub/software/scm/git/docs/git-diff.html</t>
<t tx="hasletpara.20130829091513.1651">---++++ Program Slicing

http://pages.cs.wisc.edu/~reps/</t>
<t tx="hasletpara.20130902092846.1747">---++++++ Article: FRUIt
 
Uses data mining techniques to produce views inside an eclipse plugin.  This was done to help developers cope with the overhead of understanding frameworks.

Possible followup

   * G. I. Webb and S. Zhang. Beyond association rules: Generalized rule discovery. http://www.csse.monash.edu.au/~webb/Files/WebbZhang03.pdf.

   * A. Michail. Data mining library reuse patterns using generalized association rules. In Proceedings of the International Conference on Software Engineering, pages 167–176. ACM Press, 2000.

   * Learning from examples to improve code completion systems http://dl.acm.org/citation.cfm?id=1595728</t>
<t tx="hasletpara.20130903084319.1538">---+++++ Git web pages
Comparison between Git and Mecurial
http://alblue.bandlem.com/2011/03/mercurial-and-git-technical-comparison.html</t>
<t tx="hasletpara.20130905084546.1651">\section{Background}
There are a number of methodologies, designs and practices that are related.  These have been used in the past to come to a common understanding or a different abstraction of the source code.
@others</t>
<t tx="hasletpara.20130905084546.1654">\subsection{Other Background}
@
GIT
Distributed Version control
references from other non-acedemic sources
@c
@others</t>
<t tx="hasletpara.20130905084546.1663">\subsection{Differences in created code}
When you assign two developers a project you often end up with two vastly different implementations.  
A possible reason for this would be that the requirements have not been made clear enough to obtain the correct implementation. This however suggests that there is only one possible solution and that one of the implementations better encapsulates the requirements.  
The reason also does not take into account what may learned about the problem during the act of programming  a solution.  While programming the solution it could be revealed that the requirements are incorrectly stated. 
Additionally there is normally a significant amount of leeway within the requirements which could make either implementation adequate for the task.
Judging by the regularity of differing implementations is spite of presenting the same requirements indicates that the notion of correct and precise requirements are myth.  

The other factor in implementing a set of requirements are the programmers or business analysts themselves.  
People tend to think differently and have their own ways of internally representing information.
This is an asset rather that a liability as it means that what one person overlooks due to their perspective may be considered by someone else.
The problem with this is when doing a software development project communicating a particular understanding is lossy and is never perfect.

What is required is a way of translating some of the information between the different understandings that represent the same functional outcome.  </t>
<t tx="hasletpara.20130905084546.1665"> \subsection{Other tools}
 There are a
 Although their are a number of tools that can represent aspects of the source code in a diffrent manner they come with their own challenges.
 (CodeCity)
 There is a time and thought overhead to adjust to the new perspective that these tools bring. 
 Time must be spent learning how to use the new tool. 
 Often it only displays a subset of information about the code.
 Even UML is better used as an overview for Object Oriented Programs and when it comes to actually coding you have to revert to editing text for a particular programming language.
 
  Most of the current tools on the market are focused on forcing people to be on the same page. 
 One of the exceptions to this is GIT which because of its decentralised nature provides a way to explore different ways to approach a solution.
 Even GIT does not go far enough.
 as two segments of code although written differently can provide an equivilent set of functions</t>
<t tx="hasletpara.20130909092051.1567">\subsection{How the proposed work is useful}
There </t>
<t tx="hasletpara.20130909092051.1568">\subsection{Previous Solutions}
There are a number of way these issues has been addressed in the past however each of them have weaknesses

 </t>
<t tx="hasletpara.20130909092051.1589">\subsection{Personal Intellectual Property}
In the software development career there is quite a high turnover of both permanent and contract staff. In most circumstances with each change of contract or job the contractor or employee has to relinquish ownership of everything they have written while in service of a company.  According to a recent article in Vanity Fair \cite{VanityFair} failure to follow these rules is dire. I realize that intellectual property (IP) is a complicated subject and that it will take more than a Masters Thesis to address.  It is my hope that this thesis will provoke a greater discussion on the subject.  The ability to have your own separate personalized refactored view of the code raises the question "Who owns that view".  Currently if someone  enters into a contract with a company normally the company takes ownership of all the code that they produce.  When they leave the company unless all their code is open source they cannot take any of it with them.  This in turn means that when joining a new company although a programmer may have knowledge about an area it takes longer to apply that knowledge as they need to start again from scratch.  When they leave a company and they have an individualized view of the code however highlights the interesting communication issue we have been talking about.  It is now uneconomic for the company to retain the individualized view as they already have a different copy that is more relevant and understandable to themselves. Bringing in a new developer and persuading them to understand the code from the leaving party's point of view is also pointless. The only real remaining concern for companies is how much of leaving parties view is their own innovation and how much of it contains innovation from the company or client that the company is writing applications for. As far as knowledge that the person possesses this has not been an issue for the most companies but they may be more sensitive about code. Although I cannot make any promises one of the things that I will be looking into is a way to elegantly unhook the view so that it only retains the changes and interpretations of the individual.      

I hope that this discussion will provide a step towards the point where individual developers can develop their own general purpose frameworks. This benefits both the individual programmer and the companies that they are involved with as they can more quickly become productive in their next contract.  It also encourages novel innovation in a way which open source cannot as it is harder to reap the benefits of your own open source projects.   

       </t>
<t tx="hasletpara.20130909092051.1590">Ultimately doomed to fail as it fails to capitilise on each persons different points-of-view</t>
<t tx="hasletpara.20131112095537.1645">Each person has different ways in which they best understand, develop and refactor code.  Sometimes there are even different ways in which an individual will approach a different task or challenge.  We will now examine those issues in more detail

@

 This is meant to be done to tidy the code in preparation for other developers to add further features. What invariably happens in practice is the code is left in what appears to be a mess.  This is often blamed on someone not appropriately cleaning up after themselves. It could also be explained by the fact that there is more than one way people could best view the code.

The refactoring that one person has done is hard to comprehend by someone with a differing perspective.  This is often blamed as the refactored code being poorly documented but in business there is little time to explain your individual perspective in depth.  Well documented code would also be code that cluttered with different documentation from each developer who has a different perspective. Some of this documentation clutter could be caused by something as having a different way to explain the code.

It is not just different people that could have a different perspective. Different changes could also involve understanding the code from a different point of view.  This means some of the perceived mess in your own code could simply be that you are doing a different task.

When any of these things happen you need to refactor the code to get it into a condition where you can make the appropriate change.  This presents a problem as when you refactor you do not just refactor your individual view for the function you intend to implement.  What happens is you refactor the view for everyone.  This results in a lot of confused people who have to re-learn the code from the point of view you had when making that individual change.

This means after the refactoring the code is again in a foreign format which takes time to adjust to in order to once again become productive.

What is required is a way to retain the code as much as possible in both its original format for other developers and in the new refactored format to best apply a change or a series of changes.
@c</t>
<t tx="hasletpara.20131112095537.1646">@
This would suggest that the internal way that each person interprets and understands the code not only affects the results that they produce but also the speed at which they become familiar with existing code.

In the coding environment this asset is often neglected as everyone is forced to focus on the single source.
This source is at least initially in a foreign format which takes time to adjust to in order to become productive.

The learning process can be sped up by providing the means to change that foreign format into something that seems to make more logical sense. The very act of going through the code and reprocessing it in a clearer form will help with the understanding of the code.
@c</t>
<t tx="hasletpara.20131115102112.1759">Instead of just writing a TODO to say this is not the best way to implement the code placing some marker in the file so that whoever copies the code now become responsible for manually coping across the unwanted hack or rewriting it properly is a good feature. The way of marking code as being superfluous or 

@  
The advantages to doing this are
The way to test this is to mark some code as being functionall equivilent i
@c
  

@
The solution to these issues that I am proposing goes a little further in separating
@c
@
initially as a diff tool for GIT
initially dealing with code comments that may not need to be transfered
@c</t>
<t tx="hasletpara.20131121100256.1776"></t>
<t tx="hasletpara.20131121100256.1778">&lt;&lt;Front part&gt;&gt;

&lt;&lt;Introduction&gt;&gt;

&lt;&lt;Background&gt;&gt;

&lt;&lt;How it was implemented&gt;&gt;

&lt;&lt;How UI was implemented&gt;&gt;

&lt;&lt;Evaluation&gt;&gt;

&lt;&lt;Conclusion&gt;&gt;

</t>
<t tx="hasletpara.20131121100256.1779">VICTORIA UNIVERSITY OF WELLINGTON

Te Whare Wananga o te ¯ Upoko o te Ika a M ¯ aui ¯

School of Engineering and Computer Science

Te Kura Matai P ¯ ukaha, P ¯ urorohiko ¯

PO Box 600

Wellington

New Zealand</t>
<t tx="hasletpara.20131121100256.1780">Chat by Searching</t>
<t tx="hasletpara.20131121100256.1781">Alexandre Sawczuk da Silva</t>
<t tx="hasletpara.20131121100256.1782">
Supervisors: Xiaoying Gao, Peter Andreae</t>
<t tx="hasletpara.20131121100256.1783">October 17, 2013</t>
<t tx="hasletpara.20131121100256.1784">Submitted in partial fulﬁlment of the requirements for

Bachelor of Engineering — Software Engineering.</t>
<t tx="hasletpara.20131121100256.1785">
Chatbots, which are computer programs that have conversations with users,

are a well-established technology. However, the conversational ability of the typ-
ical chatbot is greatly restricted, since it does not have access to external sources

of information. The objective of this project was to investigate how the per-
formance of a chatbot could be improved by connecting it with a knowledge

source that could be used during its interactions with users. A new chatbot, Wal-
lace, was created by extending Alice to incorporate knowledge from Wikipedia

into its conversations. Mechanisms were designed and developed to retrieve

Wikipedia pages, parse them, and select suitable sentences for the conversation.

A user evaluation was conducted on the prototype, which showed that Wallace

was generally more effective at providing factual answers to questions denoting

an informational need than Alice. Participants also expressed that Wallace was

more speciﬁc and more entertaining than Alice. This project identiﬁed several

directions for future development, especially involving human-computer inter-
action and artiﬁcial intelligence.</t>
<t tx="hasletpara.20131121100256.1786">&lt;&lt;header&gt;&gt;

&lt;&lt;title&gt;&gt;

&lt;&lt;author&gt;&gt;

&lt;&lt;Supervisors&gt;&gt;

&lt;&lt;Date&gt;&gt;

&lt;&lt;towards&gt;&gt;

</t>
<t tx="hasletpara.20131121100256.1788">
1.1 Project Objectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1</t>
<t tx="hasletpara.20131121100256.1789">&lt;&lt;Title Page&gt;&gt;

&lt;&lt;Abstract&gt;&gt;

Acknowledgements

Contents

List of Figures
</t>
<t tx="hasletpara.20131121100256.1790">
2.1 History of Chatbots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

2.2 Educational Chatbots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

2.3 Chatbots for Bulletin Boards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

2.4 Chatbots with Emotions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.5 Commercial Chatbots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.6 Proﬁle-building Chatbots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.7 Chatbots with Learning Capabilities . . . . . . . . . . . . . . . . . . . . . . . . 6


General overview

understanding of definitions

Benefits

How to do it / model it tjink about it

types of

tools that could help

summary</t>
<t tx="hasletpara.20131121100256.1791">3 Development of Chatbot Functionality 7

3.1 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

3.2 System Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

3.2.1 Chosen Technologies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

3.2.2 The Existing Alice Framework . . . . . . . . . . . . . . . . . . . . . . . 9

3.2.3 System Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

3.2.4 Enhancing the Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

3.3 Integrating Search to Wallace . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.3.1 Triggering the Search Behaviour . . . . . . . . . . . . . . . . . . . . . . 12

3.3.2 Parsing a Wikipedia Page . . . . . . . . . . . . . . . . . . . . . . . . . . 13

3.3.3 Simple Sentence Selection Approach . . . . . . . . . . . . . . . . . . . . 14

3.3.4 Sophisticated Sentence Selection Approach . . . . . . . . . . . . . . . . 14

3.3.5 Handling Follow-up Interaction . . . . . . . . . . . . . . . . . . . . . . 15

3.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

Design and implemenattion

libraries used

each of the compoments

difficulties and problems</t>
<t tx="hasletpara.20131121100256.1792">4 Development of the User Interface 19

4.1 User Interface Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

4.2 User Interface Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

4.3 Initial SWT Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

4.4 Final JavaFX Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21


How it works in action</t>
<t tx="hasletpara.20131121100256.1793">5 Formative System Evaluation 23

5.1 Evaluation Design and Execution . . . . . . . . . . . . . . . . . . . . . . . . . . 23

5.1.1 Conversational Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

5.1.2 System Performance Questions . . . . . . . . . . . . . . . . . . . . . . . 24

5.1.3 Reviewing the Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

5.2 Analysis of Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

5.2.1 Quantitative Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

5.2.2 Qualitative Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

</t>
<t tx="hasletpara.20131121100256.1794">6 Conclusions and Future Work 31

&lt;&lt;Recommendations&gt;&gt;
</t>
<t tx="hasletpara.20131121100256.1795">
6.1 Recommendations for Future Work . . . . . . . . . . . . . . . . . . . . . . . . . 32</t>
<t tx="hasletpara.20131122093500.1829">Being able to provide manual instructions and hints about how the source control should treat set blocks of code needs investigation. If a record is kept of conflicting items that are marked as being functionally equivalent they do not need to be included in a merge. The simplest of these would be comments that have been noted as being functionally irrelevant. If there is a conflict with the comment in one branch with a line of code in another branch, there could be an indication about which should be preferred. Another reason to mark something as functionally irrelevant might be if there is throw-away code that you do not want propagated over your whole version control system.</t>
<t tx="hasletpara.20131122093500.1830">One way of identifying functionally equivalent code would be to use annotations in the source file as indicators. A unique key would possibly be needed if the block of code was functionally equivalent to differing code in other branches. A different annotation may need to be used to indicate that items such as code for debugging purposes, throwaway code or comments specific to a view are not merged. The benefit of this is that it can eliminate unnecessary merging when either the code has been marked as having same intention or if the code is irrelevant in other branches.</t>
<t tx="hasletpara.20131122093500.1831">A way to keep track of irrelevant code would be to create a third branch which only pulls down the changes and is never used to commit changes. Although this would be suitable for the situation where there was throwaway code, comments or debugging it would be harder to maintain without additional tooling. It would also be harder to manually identify equivalent code segments that do not need to be merged.</t>
<t tx="hasletpara.20131122093500.1832">There is already some refactoring aware merge tools that have been researched. An example would be the ''JDime'' system proposed by Apel \cite{Apel2011}. Most of these however, are general purpose and have been created as difference or merge tools that can be plugged into various version control systems. What this could mean is that using the progressive changes in a distributed system has not been explored.</t>
<t tx="hasletpara.20131122093500.1833">The proposed approach is to look at the code associated with Git and JDime and figure out how we can relate each step in git to a merge. Using JDime and Git as a starting point see anything can be gained by using the additional steps rather than just merging the top items in a single merge . This should not be as computationally expensive as it sounds if the semi-structured approach set forward by Le{\ss}nich and Apel should mean that this is only necessary for conflicting items \cite{LeBenich2012} \cite{Apel2011}. By merging some of the refactoring aware functionality of JDime with GIT we plan to further reduce the amount of merge conflicts. </t>
<t tx="hasletpara.20131122093500.1834">Evidence of this could be found by a reduced number of conflicts. What this could mean for developers in a multi-developer environment is that the branch of code that they work on could be in a more consistent state. This would hopefully reduce the time spent trying to comprehend the changes that another developer has made.

This paper will test the view that being able to automatically discern and manually mark items as being related between two will reduce the amount of conflicts that occur. Initially the automatic marking all comments as being irrelevant will be tested to see if it reduces the merge conflicts. The results will be compared against the ''JDime'' system without any additional features. As things progress this could give us a clearer indication about what things could be manually marked as being equivalent.</t>
<t tx="hasletpara.20131122093500.1835">One of the things that will be investigated is if the changing of variable or method names is possible. This is going to be a challenge as if the method is or variable is not private or local the use of it could be spread over a number of files. For this reason initially only private methods, private variables and local variables will be considered. Investigation needs to be done to see if some of these changes are already covered by ''JDime''.</t>
<t tx="hasletpara.20131122093500.1836">This project will also test if there are any advantages in comparison on a check-in by check-in basis rather than simply comparing the most recent check-in for two branches against each other. Again this will be done by examining if the total amount of conflicts can be reduced. Some of the conflicts will also be manually examined to see if they are simpler or more simply resolved using this process. This could identify if the maintenance of the version control system could be simplified.</t>
<t tx="hasletpara.20131126100506.1825"></t>
<t tx="hasletpara.20131126100506.1826">(cached) paranhaslett.20130826181255.3074
Diff...
  NOTES
- @others+ @others
?        +
+ 
+ Git tutorial
+ http://www.vogella.com/articles/Git/article.html</t>
<t tx="hasletpara.20131126100506.1827">NOTES
@others

Git tutorial
http://www.vogella.com/articles/Git/article.html</t>
<t tx="hasletpara.20131126100506.1828">NOTES
@others</t>
<t tx="hasletpara.20131127121911.1848"></t>
<t tx="hasletpara.20131127121911.1849">(cached) paranhaslett.20130826181255.3074
Diff...
  NOTES
- @others+ @others
?        +
+ 
+ Git tutorial
+ http://www.vogella.com/articles/Git/article.html</t>
<t tx="hasletpara.20131127121911.1850">NOTES
@others

Git tutorial
http://www.vogella.com/articles/Git/article.html</t>
<t tx="hasletpara.20131127121911.1851">NOTES
@others</t>
<t tx="hasletpara.20131127121911.1852"></t>
<t tx="hasletpara.20131127121911.1853"></t>
<t tx="paranhaslett.20130826181255.2958"></t>
<t tx="paranhaslett.20130826181255.2959">DOCUMENTS
@others</t>
<t tx="paranhaslett.20130826181255.3057">STRUCTURES
@others</t>
<t tx="paranhaslett.20130826181255.3058"></t>
<t tx="paranhaslett.20130826181255.3059">String name
ArrayList&lt;Tag&gt;
</t>
<t tx="paranhaslett.20130826181255.3060">String name (optional)
</t>
<t tx="paranhaslett.20130826181255.3061">String name
Arraylist &lt;Tag&gt;
Menu content
</t>
<t tx="paranhaslett.20130826181255.3062"></t>
<t tx="paranhaslett.20130826181255.3063"></t>
<t tx="paranhaslett.20130826181255.3068"></t>
<t tx="paranhaslett.20130826181255.3074">NOTES
@others</t>
<t tx="paranhaslett.20130826181255.3103">
@others
</t>
<t tx="paranhaslett.20130826181255.3104">This has been a bit tricky so far
</t>
<t tx="paranhaslett.20130826181255.3105">Nice to look at but will it work with this
</t>
<t tx="paranhaslett.20130826181255.3106"></t>
<t tx="paranhaslett.20130826181255.3107">need two different branches of near equivilent code 

Maybe

@others
</t>
<t tx="paranhaslett.20130826181255.3109">Ideas

@others

</t>
<t tx="paranhaslett.20130826181255.3110">

 
</t>
<t tx="paranhaslett.20130826181255.3111">
A
B
C
</t>
<t tx="paranhaslett.20130826181255.3112">
1.A
2.B
3.C
</t>
<t tx="paranhaslett.20130826181255.3113">
A
println("");
C
</t>
<t tx="paranhaslett.20130826181255.3114">
A
B
 LC

A
B
C

A
 LB
  LC

A
 LB
 LC

A
 LB
C
</t>
<t tx="paranhaslett.20130826181255.3115">x=x+1;
println("foo");

and

println("foo");
x=x+1;

Need to also test unequivlent code

x=x+1;
println(x);

and

println(x);
x=x+1;
</t>
<t tx="paranhaslett.20130826181255.3116">needs a seperate structure to hold differently ording info

File
A
B
C

Structure

B
 LA
 LC
</t>
<t tx="paranhaslett.20130826181255.3117">
View A                   View B

Term A --------*---------Term B
         Synonamous Item

Alternately Using Java auto detect synonamous items an code equivlency

Tomarto
Tomayto
</t>
<t tx="paranhaslett.20130826181255.3118">Actually it is easier when we only need to comapre two views with each other
</t>
<t tx="paranhaslett.20130826181255.3119">
infix 1 + 1 or 1.add(1);
prefix + 1 1 or add(1,1)
suffix 1 1 + or 1.1.add;
</t>
<t tx="paranhaslett.20130826181255.3120">---+++ Papers I am currently reading
</t>
<t tx="paranhaslett.20130826181255.3121">---++++ Code Source Mining
</t>
<t tx="paranhaslett.20130826181255.3122">---++++++ Article: Mining Software Repositories with iSPAROL and a Software Evolution Ontology

http://dl.acm.org/citation.cfm?id=1268983.1269048

In this paper they present EvoOnt which is a common language useful for extracting informtion out of code repositories. As it is based on the existing Web Ontology Language (OWL) they believe that it is extendable.  They claim that it can be used to detect bad smells in Java code. Although this would be useful as a tool to view existing code it only appears capable of representing subsets of a central code repository. Thats said the underlying language which they are using deserves further study as it may be able to help two seperate views negotiate what is common between them. This would be a step towards discovering code equivlencies.

Possible followup
   * Using information fragments to answer the questions developers ask http://dl.acm.org/citation.cfm?id=1806828
   * Sample Spaces and Feature Models: There and Back Again http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4626837&amp;tag=1
   </t>
<t tx="paranhaslett.20130826181255.3123">---++++++ Article: TARE An Exchange Language for Mining Software Repositories
http://dl.acm.org/citation.cfm?id=1137983.1137990

Another exchange language useful for data mining. It differs in that it is not based on an existing language. 
</t>
<t tx="paranhaslett.20130826181255.3124">
Another language useful for data mining. It differs in that it is not based on an existing language. 
---++++ CSCW

---+++++ What is CSCW?
Computer supported cooperative work 

http://en.wikipedia.org/wiki/Computer-supported_cooperative_work

@others
</t>
<t tx="paranhaslett.20130826181255.3125">---+++++ Article: CSCW and Education

http://dl.acm.org/citation.cfm?id=2441955.2442035
</t>
<t tx="paranhaslett.20130826181255.3126">---+++++ Article: Why CSCW needs Science Policy

http://dl.acm.org/citation.cfm?doid=2441776.2441902
</t>
<t tx="paranhaslett.20130826181255.3127">---++++ Modeling and Graphical Code viewing

@others
</t>
<t tx="paranhaslett.20130826181255.3128">---++++++ Article: An EXtensible Framework for providing Dynamic Data Structure Visualisations

http://dl.acm.org/citation.cfm?id=1028174.971433
</t>
<t tx="paranhaslett.20130826181255.3129">---+++++ Article: Constructing  Multi-View Editing Eviroments Using MViews

   * Developing multiple grapical front ends for programming
   * SNART

It focuses on making each subset view a part of a central whole. It uses a central database to hold information about program structure and semantics. What I am attempting to do with my concept of views is to treat each view as its individual whole with items deamed to be equivilent syncronsised with the views they are equivilent to.  There need to be some way of detecting these code equivlencies.

Futher articles about Mviews and other products that involve co-operating view can be found on John C Grundys home page

https://sites.google.com/site/johncgrundy/Home
</t>
<t tx="paranhaslett.20130826181255.3130"></t>
<t tx="paranhaslett.20130826181255.3131">---++++++ Article: Software Dev enviroments on the web

http://dl.acm.org/citation.cfm?id=2384592.2384603
</t>
<t tx="paranhaslett.20130826181255.3132">---++++++ Article:Shrimp
</t>
<t tx="paranhaslett.20130826181255.3133">---++++++ Article: Towards a Prctical Visual OO Programming environment
What parts of Java could be reperesented by a visual represatation alone?
Can all of the OO be represented by a visual design rather than by text
</t>
<t tx="paranhaslett.20130826181255.3134">---++++  Templates and Macros
@others
</t>
<t tx="paranhaslett.20130826181255.3135">---++++++ Article: Behaviorial Similarity Matching using Concrete Source Code Templates in Logic Queries

http://dl.acm.org/citation.cfm?doid=1244381.1244398

This Paper is about identifing pattern with a particular code
</t>
<t tx="paranhaslett.20130826181255.3136">---++++++ Article: Code Templete Inference Using Langugauge Models

http://dl.acm.org/citation.cfm?doid=1900008.1900143
</t>
<t tx="paranhaslett.20130826181255.3137">---++++++ Article: Marco: safe, expressive macros for any language

http://dl.acm.org/citation.cfm?id=2367163.2367199

The reason why I was intersted in this paper is that one way to implement a seperate view would be to write programs that are responsible for assembling the program end product.  The reason I have gone off that idea is that this still requires a central point that contains the "truth" while the seperate views are considered as being simply small subsets of that "truth". I still admire the ability to be language agnostic however.
</t>
<t tx="paranhaslett.20130826181255.3138">---++++++ Article: Towards Modular Code Generators Using Symmetric Language-Aware Aspects

http://dl.acm.org/citation.cfm?doid=2068776.2068782
</t>
<t tx="paranhaslett.20130826181255.3139">---++++  Version Control
@others
</t>
<t tx="paranhaslett.20130826181255.3140">---+++++ Article: Modern Version Control

http://dl.acm.org/citation.cfm?id=2382456.2382510
</t>
<t tx="paranhaslett.20130826181255.3141">---+++++ Article: Version Control in Crosscutting Framework-Based Development

http://portal.acm.org/citation.cfm?doid=1363686.1363862

This article highlights the some of the conditions where version control may not understand or cater for code structured in a particular manner. although they mention that this also could be an issue with Object Oriented Frameworks OOF they focus more on Aspect Oriented and crosscutting frameworks. They also have developed TOFRA to deal with changes in an Aspect. As a personalized view could be cross cutting this article could be of interest. The way in which aspect oriented programming links with vastly different parts of the same structure could be similar to how one personalized view would appear to another. The fact that a small configuration change within an aspect can affect vastly different parts of the application will cause similar complexities as changing items that might be related in one personal view but unrelated in another. Even worse would be changing items that appear unrelated in one view but are connected in another.
</t>
<t tx="paranhaslett.20130826181255.3142">---++++  View Mapping Language

@others
</t>
<t tx="paranhaslett.20130826181255.3143">---+++++ Article: Mappings the glue in an integrated system
   * View mapping language
   * VML
   * Code equivlency
</t>
<t tx="paranhaslett.20130826181255.3144">---+++++ Article:User-centered design of a visual data mapping tool
 http://dl.acm.org/citation.cfm?id=2254556.2254646
</t>
<t tx="paranhaslett.20130826181255.3145">---+++++ Article:Domain-specific visual languages for specifying and generating data mapping systems
http://www.sciencedirect.com/science/article/pii/S1045926X04000102#

This is also by John Grundy of Mviews Fame
</t>
<t tx="paranhaslett.20130826181255.3146">---++++++ Article: Building Usage Contexts During Program Comprehension
</t>
<t tx="paranhaslett.20130826181255.3147"></t>
<t tx="paranhaslett.20130826181255.3148"></t>
<t tx="paranhaslett.20130826181255.3149"></t>
<t tx="paranhaslett.20130826181255.3150"></t>
<t tx="paranhaslett.20130826181255.3157"></t>
<t tx="paranhaslett.20130827232850.1595">



</t>
<t tx="paranhaslett.20131022191134.1801">Monday
Tuesday
Wednesday
Thursday
Friday</t>
<t tx="paranhaslett.20131022191134.1802"></t>
<t tx="paranhaslett.20131022191134.1803">  Update thesis to add more about understanding code 
  Add current references about understanding the code to the thesis
  create a diagram of git repositories
  find some papers about craeting structural overlays onto existing code 
  connect eclispe to repo at home
  submit code to repo
</t>
<t tx="paranhaslett.20131122184051.1887"></t>
<t tx="paranhaslett.20131122184051.1888">(cached) paranhaslett.20130826181255.3074
Diff...
  NOTES
- @others
?        -
+ @others- 
- Git tutorial
- http://www.vogella.com/articles/Git/article.html</t>
<t tx="paranhaslett.20131122184051.1889">NOTES
@others</t>
<t tx="paranhaslett.20131122184051.1890">NOTES
@others

Git tutorial
http://www.vogella.com/articles/Git/article.html</t>
<t tx="paranhaslett.20131126202038.1911"></t>
<t tx="paranhaslett.20131126202038.1912">(cached) paranhaslett.20130826181255.3074
Diff...
  NOTES
- @others
?        -
+ @others- 
- Git tutorial
- http://www.vogella.com/articles/Git/article.html</t>
<t tx="paranhaslett.20131126202038.1913">NOTES
@others</t>
<t tx="paranhaslett.20131126202038.1914">NOTES
@others

Git tutorial
http://www.vogella.com/articles/Git/article.html</t>
</tnodes>
</leo_file>
